<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <meta name="author" content="Adrian Mejia">
    <link rel="author" href="humans.txt" />
    <meta name="description" content="JavaScript tutorials and web development articles including topics like NodeJS, Angular, VueJS, Data Structures and Algorithms.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">

    <link rel="alternative" href="/atom.xml" title="Adrian Mejia Blog" type="application/atom+xml">

    
    <title>Data Structures in JavaScript: Arrays, HashMaps, and Lists | Adrian Mejia Blog</title>

    <!-- Favicons -->
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon-precomposed" sizes="60x60" href="/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="/favicon-128.png" sizes="128x128" />
    <meta name="application-name" content="Adrian Mejia's Blog"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="/mstile-310x310.png" />
    <meta name="msapplication-notification" content="frequency=30;polling-uri=http://notifications.buildmypinnedsite.com/?feed=https://adrianmejia.com/atom.xml" />

    <link rel="canonical" href="https://adrianmejia.com/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/" />
    <!-- Open Graph -->
    <meta property="og:url" content="https://adrianmejia.com/Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial/" />
    <meta property="og:site_name" content="Adrian Mejia Blog" />
    <meta property="og:type" content="article" />
    <meta property="og:description" content="When we are developing software, we have to store data in memory. However, many types of data structures, such as arrays, maps, sets, lists, trees, graphs, etc., and choosing the right one for the task can be tricky. This series of posts will help you know the trade-offs so that you can use the right tool for the job!" />
    <meta property="og:image" content="https://adrianmejia.com/images/data-structures-time-complexity-lists-arrays-stacks-queues-hash-maps-sets-large.jpg" />
    <meta property="og:title" content="Data Structures in JavaScript: Arrays, HashMaps, and Lists" />
    <meta property="fb:app_id" content="761831487293468" />
    <meta property="fb:admins" content="895685163"/>
    <!-- /Open Graph -->

    <script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-24183929-4', 'auto');
ga('send', 'pageview');
</script><script async defer src='https://www.google-analytics.com/analytics.js'></script>


    <!-- Critical Styles -->
    <style media="screen">
      .overlay { display: none }
    </style>
    
<link rel="stylesheet" href="/stylesheets/main.css">

    <!-- loadDeferredStyles -->
    <noscript id="deferred-styles">
      
<link rel="stylesheet" href="/stylesheets/font-awesome.min.css">
    </noscript>

    <script>
      var loadDeferredStyles = function() {
        var addStylesNode = document.getElementById("deferred-styles");
        var replacement = document.createElement("div");
        replacement.innerHTML = addStylesNode.textContent;
        document.body.appendChild(replacement)
        addStylesNode.parentElement.removeChild(addStylesNode);
      };
      var raf = requestAnimationFrame || mozRequestAnimationFrame ||
          webkitRequestAnimationFrame || msRequestAnimationFrame;
      if (raf) raf(function() { window.setTimeout(loadDeferredStyles, 0); });
      else window.addEventListener('load', loadDeferredStyles);
    </script>

  <meta name="generator" content="Hexo 5.0.2"></head>
  <body>
    <header class="titlebar mdl-shadow--2dp">
      <div class="container align-center flexbox--space-between">
        <!-- <div class="row"> -->
          <!-- <div class="col-md-12"> -->
            <span class="hidden-mobile-up">
              <i class="fa fa-bars" aria-hidden="true"></i>
            </span>

            <a href="/" class="align-center m-y-2">
              <img src="/images/adrianmejia-logo.png" alt="Adrian Mejia Logo" class="animation--bounce-in"/>
              <h1 class="hidden-mobile-down hidden">
                Adrian Mejia
              </h1>
            </a>

            <nav class="hidden-mobile-down navbar">
              
                <a href="/#home" class="animation--radial-out" id="Home" onclick="track('/#home', 'menu', true)">Home</a>
              
                <a href="/#trending-posts" class="animation--radial-out" id="Trending" onclick="track('/#trending-posts', 'menu', true)">Trending</a>
              
                <a href="/#popular-posts" class="animation--radial-out" id="Popular" onclick="track('/#popular-posts', 'menu', true)">Popular</a>
              
                <a href="/#about" class="animation--radial-out" id="About" onclick="track('/#about', 'menu', true)">About</a>
              
                <a href="/blog/" class="animation--radial-out" id="Blog" onclick="track('/blog/', 'menu', true)">Blog</a>
              
            </nav>

            <a href="#" id="search-modal" onclick="track('#search', 'search', true)" class="open-overlay">
  <i class="fa fa-search" aria-hidden="true"></i>
</a>

<div id="search-overlay" class="overlay" aria-hidden="true">

  <script id="movie" type="text/x-handlebars-template">
    <article class="movie">
      {{#photos.0}}
      <a href="/{{path}}">
        <img class="movie-image" src="{{photos.0}}" />
      </a>
      {{/photos.0}}

      <div class="movie-meta">
        <div class="movie-title">
          <a href="/{{path}}">
            {{{_highlightResult.title.value}}}
          </a>
          <span class="movie-year">
            {{updatedYear}}
          </span>
        </div>

        <div class="movie-rating">
          {{#stars}}
            <span class="ais-star-rating--star{{^.}}__empty{{/.}}">
            </span>
          {{/stars}}
        </div>

        <p>
          {{{_highlightResult.excerptStrip.value}}}
        </p>

        <div class="movie-genres">
          {{#tags}}
            <div class="movie-genre">
              {{.}}
            </div>
          {{/tags}}
        </div>
      </div>
    </article>
  </script>

  <div class="search-container">

    <div class="top">
      <div class="search-button">
        <i class="fa fa-search"></i>
      </div>
      <div class="input-container">
        <input type="text" id="search-box" />
        <div id="stats"></div>
      </div>
      <a href="#" class="close-overlay">
        <i class="fa fa-times"></i>
      </a>
    </div>

    <div class="content">
      <div class="facets">

        <div class="facet">
          <div id="clear-all" class="facet-title"></div>
        </div>

        <div class="facet">
          <div class="facet-title">
            <i class="fa fa-tags" aria-hidden="true"></i> Tags
          </div>
          <div id="tags"></div>
        </div>

        <div class="facet">
          <div class="facet-title">
            <i class="fa fa-folder-o" aria-hidden="true"></i>
            Categories
          </div>
          <div id="categories"></div>
        </div>

        <div class="facet">
          <div class="facet-title">
            <i class="fa fa-eye" aria-hidden="true"></i>
            Views
          </div>
          <div id="ratings"></div>
        </div>

        <div class="facet">
          <div class="facet-title">
            <i class="fa fa-calendar" aria-hidden="true"></i>
            Year
          </div>
          <div id="year"></div>
        </div>
      </div>

      <div class="canvas">
        <div id="hits"></div>

        <div id="pagination"></div>

        <div>Powered by <img src="/images/Algolia_logo_bg-white.svg" height="30" alt="Algolia search"></div>
      </div>
    </div>
  </div>
</div>


<script src="/js/search.babel.js"></script>


      </div>
    </header>
    <nav class="hidden-mobile-up mdl-shadow--2dp">
      <div class="container flexbox--space-between navbar">
        
          <a href="/#home" class="animation--underline-from-center">Home</a>
        
          <a href="/#trending-posts" class="animation--underline-from-center">Trending</a>
        
          <a href="/#popular-posts" class="animation--underline-from-center">Popular</a>
        
          <a href="/#about" class="animation--underline-from-center">About</a>
        
          <a href="/blog/" class="animation--underline-from-center">Blog</a>
        
      </div>
    </nav>

    <main>
      <!--https://developers.google.com/search/docs/data-types/articles-->
<!--http://schema.org/BlogPosting-->
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": ""
  },
  "headline": "Data Structures in JavaScript: Arrays, HashMaps, and Lists",
  
  "image": {
    "@type": "ImageObject",
    "url": "https://adrianmejia.com/images/data-structures-time-complexity-lists-arrays-stacks-queues-hash-maps-sets-large.jpg",
    "height": 360,
    "width": 728
  },
  
  "datePublished": "2018-04-28T19:20:40-04:00",
  "dateModified": "2020-12-15T18:46:40-05:00",
  "author": {
    "@type": "Person",
    "name": "Adrian Mejia"
  },
   "publisher": {
    "@type": "Organization",
    "name": "Adrian Mejia",
    "logo": {
      "@type": "ImageObject",
      "url": "https://adrianmejia.com/images/logo.png",
      "width": 347,
      "height": 50
    }
  },
  "description": "When we are developing software, we have to store data in memory. However, many types of data structures, such as arrays, maps, sets, lists, trees, graphs, etc., and choosing the right one for the task can be tricky. This series of posts will help you know the trade-offs so that you can use the right tool for the job!"
}
</script>


<article class="container post">

  <section class="hero">
    <div class="muted">
      <a class="category-link" href="/categories/coding/">Coding</a> > <a class="category-link" href="/categories/coding/data-structures-and-algorithms-dsa/">Data Structures and Algorithms (DSA)</a>
    </div>

    <h1>Data Structures in JavaScript: Arrays, HashMaps, and Lists</h1>

    <div class="muted">
      <span title="Last time this post was updated">
        <i class="fa fa-calendar" aria-hidden="true"></i>
        Last updated
        <time datetime="2020-12-15T23:46:40.000Z" itemprop="dateUpdated">December 15th 2020</time>
      </span>

      
        <span class="m-x-2" title="Pageviews">
          <i class="fa fa-eye" aria-hidden="true"></i>
          162.8k
        </span>
      

      <span class="m-x-2" title="Click to go to the comments section">
        <a href="#disqus_thread">
          <i class="fa fa-comment-o" aria-hidden="true"></i>
          <span class="disqus-comment-count" data-disqus-url="https://adrianmejia.com/Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial/">0</span>
        </a>
      </span>

      
        <span>
          <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithms/" rel="tag">algorithms</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial-algorithms/" rel="tag">tutorial_algorithms</a><span class="tag-list-count">10</span></li></ul>
        </span>
      
    </div>
  </section>

  <div class="art-container" style="background-color: #F4F0EF">
    
      <picture>
        <source media="(min-width: 728px)" srcset="/images/data-structures-time-complexity-lists-arrays-stacks-queues-hash-maps-sets-large.jpg">
        <source srcset="/images/data-structures-time-complexity-lists-arrays-stacks-queues-hash-maps-sets-small.jpg">
        <img src="/images/data-structures-time-complexity-lists-arrays-stacks-queues-hash-maps-sets-large.jpg" alt="Data Structures in JavaScript: Arrays, HashMaps, and Lists">
      </picture>
    
  </div>

  <div class="row">
    <section class="col-sm-8 p-x-2">

      <div class="post-content  toc-content ">
        <p>When we are developing software, we have to store data in memory. However, many types of data structures, such as arrays, maps, sets, lists, trees, graphs, etc., and choosing the right one for the task can be tricky. This series of posts will help you know the trade-offs so that you can use the right tool for the job!</p>
<a id="more"></a>

<p>This section will focus on linear data structures: Arrays, Lists, Sets, Stacks, and Queues.</p>
<p>You can find all these implementations and more in the Github repo:
<a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js">https://github.com/amejiarosario/dsa.js</a></p>
<hr>
<p>This post is part of a tutorial series:</p>
<p><strong>Learning Data Structures and Algorithms (DSA) for Beginners</strong></p>
<ol>
<li><p><a href="/blog/2018/04/04/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial/">Intro to algorithm’s time complexity and Big O notation</a></p>
</li>
<li><p><a href="/blog/2018/04/05/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/">Eight time complexities that every programmer should know</a></p>
</li>
<li><p>Data Structures for Beginners: Arrays, HashMaps, and Lists <strong>👈 you are here</strong></p>
</li>
<li><p><a href="/blog/2018/05/14/Data-Structures-for-Beginners-Graphs-Time-Complexity-tutorial/">Graph Data Structures for Beginners</a></p>
</li>
<li><p><a href="/blog/2018/06/11/Data-Structures-for-Beginners-Trees-binary-search-tree-tutorial/">Trees Data Structures for Beginners</a></p>
</li>
<li><p><a href="/blog/2018/07/16/Self-balanced-Binary-Search-Trees-with-AVL-tree-Data-Structure-for-beginners/">Self-balanced Binary Search Trees</a></p>
</li>
<li><p><a href="/blog/2018/04/24/Analysis-of-Recursive-Algorithms/">Appendix I: Analysis of Recursive Algorithms</a></p>
</li>
</ol>
<hr>
<h2 id="Data-Structures-Big-O-Cheatsheet"><a href="#Data-Structures-Big-O-Cheatsheet" class="headerlink" title="Data Structures Big-O Cheatsheet"></a>Data Structures Big-O Cheatsheet</h2><p>The following table is a summary of everything that we are going to cover.</p>
<blockquote>
<p>Bookmark it, pin it, or share it, so you have it at hand when you need it.</p>
</blockquote>
<p><em>Click on the <strong>name</strong> to go to the section or click on the <strong>runtime</strong> to go to the implementation</em></p>
<p><code>*</code> = Amortized runtime</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Insert</th>
<th>Access</th>
<th>Search</th>
<th>Delete</th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#Array">Array</a></td>
<td><a href="#Insert-element-on-an-array">O(n)</a></td>
<td><a href="#Access-an-element-in-an-array">O(1)</a></td>
<td><a href="#Search-an-element-in-an-array">O(n)</a></td>
<td><a href="#Deleting-elements-from-an-array">O(n)</a></td>
<td>Insertion to the end is <code>O(1)</code>. <a href="#Array-operations-time-complexity">Details here.</a></td>
</tr>
<tr>
<td><a href="#HashMaps">HashMap</a></td>
<td><a href="#Insert-element-on-a-HashMap-runtime">O(1)</a></td>
<td><a href="#Search-Access-an-element-on-a-HashMap-runtime">O(1)</a></td>
<td><a href="#Search-Access-an-element-on-a-HashMap-runtime">O(1)</a></td>
<td><a href="#Edit-Delete-element-on-a-HashMap-runtime">O(1)</a></td>
<td>Rehashing might affect insertion time. <a href="#HashMap-operations-time-complexity">Details here.</a></td>
</tr>
<tr>
<td>Map (using Binary Search Tree)</td>
<td>O(log(n))</td>
<td>-</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td><a href="#Sets">Set (using HashMap)</a></td>
<td><a href="#Set-Implementation">O(1)</a></td>
<td>-</td>
<td><a href="#Set-Implementation">O(1)</a></td>
<td><a href="#Set-Implementation">O(1)</a></td>
<td>Set using a HashMap implementation. <a href="#Set-Operations-runtime">Details here.</a></td>
</tr>
<tr>
<td>Set (using list)</td>
<td><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-set.prototype.add">O(n)</a></td>
<td>-</td>
<td><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-set.prototype.has">O(n)</a></td>
<td><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-set.prototype.delete">O(n)</a></td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td>Set (using Binary Search Tree)</td>
<td>O(log(n))</td>
<td>-</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td><a href="#Singly-Linked-Lists">Linked List (singly)</a></td>
<td><a href="#SinglyLinkedList.addLast">O(n)</a></td>
<td>-</td>
<td><a href="#LinkedList.contains">O(n)</a></td>
<td><a href="#LinkedList.remove">O(n)</a></td>
<td>Adding/Removing to the start of the list is <code>O(1)</code>. <a href="#Singly-Linked-Lists-time-complexity">Details here</a>.</td>
</tr>
<tr>
<td><a href="#Doubly-Linked-Lists">Linked List (doubly)</a></td>
<td><a href="#DoublyLinkedList.add">O(n)</a></td>
<td>-</td>
<td><a href="#LinkedList.contains">O(n)</a></td>
<td><a href="#LinkedList.remove">O(n)</a></td>
<td>Adding/Deleting from the beginning/end is <code>O(1)</code>. But, deleting/adding from the middle is <code>O(n)</code>. <a href="#Doubly-Linked-Lists-time-complexity">Details here</a></td>
</tr>
<tr>
<td><a href="#Stacks">Stack (array implementation)</a></td>
<td><a href="#Stacks">O(1)</a></td>
<td>-</td>
<td>-</td>
<td><a href="#Stacks">O(1)</a></td>
<td>Insert/delete is last-in, first-out (LIFO)</td>
</tr>
<tr>
<td><a href="#QueueNaiveImpl">Queue (naïve array impl.)</a></td>
<td><a href="#QueueNaiveImpl">O(1)</a></td>
<td>-</td>
<td>-</td>
<td><a href="#QueueNaiveImpl">O(n)</a></td>
<td>Remove (<code>Array.shift</code>) is <em>O(n)</em></td>
</tr>
<tr>
<td><a href="#QueueArrayImpl">Queue (array implementation)</a></td>
<td><a href="#QueueArrayImpl">O(1)</a></td>
<td>-</td>
<td>-</td>
<td><a href="#QueueArrayImpl">O(1)</a></td>
<td>Worst time insert is O(n). However amortized is O(1)</td>
</tr>
<tr>
<td><a href="#QueueListImpl">Queue (list implementation)</a></td>
<td><a href="#QueueListImpl">O(1)</a></td>
<td>-</td>
<td>-</td>
<td><a href="#QueueListImpl">O(1)</a></td>
<td>Using Doubly Linked List with reference to the last element.</td>
</tr>
</tbody></table>
<p>Note: <strong>Binary search trees</strong> and trees, in general, will be cover in the next post. Also, graph data structures.</p>
<h2 id="Primitive-Data-Types"><a href="#Primitive-Data-Types" class="headerlink" title="Primitive Data Types"></a>Primitive Data Types</h2><p>Primitive data types are the most basic elements, where all the other data structures are built upon. Some primitives are:</p>
<ul>
<li>Integers. E.g., <code>1</code>, <code>2</code>, <code>3</code>, …</li>
<li>Characters. E.g., <code>a</code>, <code>b</code>, <code>&quot;1&quot;</code>, <code>&quot;*&quot;</code></li>
<li>Booleans. E.g., <code>true</code> or <code>false</code>.</li>
<li>Float (floating points) or doubles. E.g., <code>3.14159</code>, <code>1483e-2</code>.</li>
<li>Null values. E.g. <code>null</code></li>
</ul>
<p>JavaScript specific primitives:</p>
<ul>
<li><code>undefined</code></li>
<li><code>Symbol</code></li>
<li><code>Number</code></li>
</ul>
<p><em>Note</em>: Objects are not primitive since they are composed of zero or more primitives and other objects.</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>Arrays are collections of zero or more elements. Arrays are one of the most used data structures because of their simplicity and fast way of retrieving information.</p>
<p>You can think of an array as a drawer where you can store things in the bins.</p>
<p><strong>Array is like a drawer that stores things on bins</strong></p>
<img src="/images/array-drawer.jpg" class="" title="Array is like a drawer that stores things on bins">


<p>When you want to search for something, you can go directly to the bin number. That’s a constant time operation (<em><code>O(1)</code></em>). However, if you forgot what cabinet had, you will have to open one by one (<em><code>O(n)</code></em>) to verify its content until you find what you are looking for. That same happens with an array.</p>
<!-- http://apprize.info/javascript/20lessons/20lessons.files/image052.jpg -->
<!-- https://cdn2.iconfinder.com/data/icons/furniture-12/48/drawer-cabinet-closet-shelf-cabin-cupboard-furntiure-512.png -->

<p>Depending on the programming language, arrays have some differences. For some dynamic languages like JavaScript and Ruby, an array can contain different data types: numbers, strings, words, objects, and even functions. In typed languages like Java/C/C++, you have to predefine the Array size and the data type. In JavaScript, it would automatically increase the size of the Array when needed.</p>
<h3 id="Arrays-built-in-operations"><a href="#Arrays-built-in-operations" class="headerlink" title="Arrays built-in operations"></a>Arrays built-in operations</h3><p>Depending on the programming language, the implementation would be slightly different.</p>
<p>For instance, in JavaScript, we can accomplish append to end with <code>push</code> and append to the beginning with <code>unshift</code>. But also, we have <code>pop</code> and <code>shift</code> to remove from an array. Let’s describe some everyday operations that we are going to use through this post.</p>
<p><strong>Common JS Array built-in functions</strong></p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Runtime</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push">array.push</a></td>
<td>O(1)</td>
<td>Insert element to the end of the array</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://devdocs.io/javascript/global_objects/array/pop">array.pop</a></td>
<td>O(1)</td>
<td>Remove element to the end of the array</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift">array.shift</a></td>
<td>O(n)</td>
<td>Remove element to the beginning of the array</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift">array.unshift</a></td>
<td>O(n)</td>
<td>Insert element(s) to the beginning of the array</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">array.slice</a></td>
<td>O(n)</td>
<td>Returns a copy of the array from <code>beginning</code> to <code>end</code>.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">array.splice</a></td>
<td>O(n)</td>
<td>Changes (add/remove) the array</td>
</tr>
</tbody></table>
<h3 id="Insert-element-on-an-array"><a href="#Insert-element-on-an-array" class="headerlink" title="Insert element on an array"></a>Insert element on an array</h3><!-- https://stackoverflow.com/a/22615787/684957 -->
<!-- https://tc39.github.io/ecma262/#sec-array.prototype.push -->
<!-- https://github.com/v8/v8/blob/master/src/js/array.js -->
<!-- https://github.com/v8/v8/blob/master/src/builtins/builtins-array.cc#L145 -->
<!-- https://tc39.github.io/ecma262/#sec-array.prototype.unshift -->

<p>There are multiple ways to insert elements into an array. You can append new data to the end or add it to the beginning of the collection.</p>
<p>Let’s start with append to tail:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertToTail</span>(<span class="params">array, element</span>) </span>&#123;</span><br><span class="line">  array.push(element);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(insertToTail(array, <span class="number">4</span>)); <span class="comment">// =&gt; [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<p>Based on the <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-array.prototype.push">language specification</a>, push just set the new value at the end of the Array. Thus,</p>
<blockquote>
<p>The <code>Array.push</code> runtime is a <em>O(1)</em></p>
</blockquote>
<p>Let’s now try appending to head:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertToHead</span>(<span class="params">array, element</span>) </span>&#123;</span><br><span class="line">  array.unshift(element);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(insertToHead(array, <span class="number">0</span>)); <span class="comment">// =&gt; [ 0, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>What do you think is the runtime of the <code>insertToHead</code> function? It looks the same as the previous one, except that we are using <code>unshift</code> instead of <code>push</code>. But there’s a catch! <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-array.prototype.unshift">unshift algorithm</a> makes room for the new element by moving all existing ones to the next position in the Array. So, it will iterate through all the elements.</p>
<blockquote>
<p>The <code>Array.unshift</code> runtime is an <em>O(n)</em></p>
</blockquote>
<h3 id="Access-an-element-in-an-array"><a href="#Access-an-element-in-an-array" class="headerlink" title="Access an element in an array"></a>Access an element in an array</h3><p>If you know the index for the element that you are looking for, then you can access the element directly like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">access</span>(<span class="params">array, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="string">&#x27;word&#x27;</span>, <span class="number">3.14</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;];</span><br><span class="line">access(array, <span class="number">0</span>); <span class="comment">// =&gt; 1</span></span><br><span class="line">access(array, <span class="number">3</span>); <span class="comment">// =&gt; &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>As you can see in the code above, accessing an element on an array has a constant time:</p>
<blockquote>
<p>Array access runtime is  <em>O(1)</em></p>
</blockquote>
<p><em>Note: You can also change any value at a given index in constant time.</em></p>
<h3 id="Search-an-element-in-an-array"><a href="#Search-an-element-in-an-array" class="headerlink" title="Search an element in an array"></a>Search an element in an array</h3><p>Suppose you don’t know the index of the data that you want from an array. You have to iterate through each element on the Array until we find what we are looking for.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">array, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(element === array[index]) &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="string">&#x27;word&#x27;</span>, <span class="number">3.14</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(search(array, <span class="string">&#x27;word&#x27;</span>)); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(search(array, <span class="number">3.14</span>)); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

<p>Given the for-loop, we have:</p>
<blockquote>
<p>Array search runtime is <em>O(n)</em></p>
</blockquote>
<h3 id="Deleting-elements-from-an-array"><a href="#Deleting-elements-from-an-array" class="headerlink" title="Deleting elements from an array"></a>Deleting elements from an array</h3><p>What do you think is the running time of deleting an element from an array?</p>
<p>Well, let’s think about the different cases:</p>
<ol>
<li>You can delete from the end of the Array, which might be constant time. <em>O(1)</em></li>
<li>However, you can also remove it from the beginning or middle of the collection. In that case, you would have to move all the following elements to close the gap. <em>O(n)</em></li>
</ol>
<p>Talk is cheap. Let’s do the code!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">array, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = search(array, element);</span><br><span class="line">  array.splice(index, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(remove(array1, <span class="number">1</span>)); <span class="comment">// =&gt; [ 0, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>So we are using our <code>search</code> function to find the elements’ index <em>O(n)</em>. Then we use the <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-array.prototype.splice">JS built-in <code>splice</code></a> function, which has a running time of <em>O(n)</em>. What’s the total <em>O(2n)</em>? Remember, we constants don’t matter as much.</p>
<p>We take the worst-case scenario:</p>
<blockquote>
<p>Deleting an item from an array is <em>O(n)</em>.</p>
</blockquote>
<h3 id="Array-operations-time-complexity"><a href="#Array-operations-time-complexity" class="headerlink" title="Array operations time complexity"></a>Array operations time complexity</h3><p>We can sum up the arrays time complexity as follows:</p>
<p><strong>Array Time Complexities</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Worst</th>
</tr>
</thead>
<tbody><tr>
<td>Access (<code>Array.[]</code>)</td>
<td><em><code>O(1)</code></em></td>
</tr>
<tr>
<td>Insert head (<code>Array.unshift</code>)</td>
<td><em><code>O(n)</code></em></td>
</tr>
<tr>
<td>Insert tail (<code>Array.push</code>)</td>
<td><em><code>O(1)</code></em></td>
</tr>
<tr>
<td>Search (for value)</td>
<td><em><code>O(n)</code></em></td>
</tr>
<tr>
<td>Delete (<code>Array.splice</code>)</td>
<td><em><code>O(n)</code></em></td>
</tr>
</tbody></table>
<h2 id="HashMaps"><a href="#HashMaps" class="headerlink" title="HashMaps"></a>HashMaps</h2><!-- https://en.wikipedia.org/wiki/Hash_table -->
<!-- https://en.wikipedia.org/wiki/Associative_array -->
<!-- https://medium.com/front-end-hacking/es6-map-vs-object-what-and-when-b80621932373 -->

<p>Maps, dictionaries, and associative arrays all describe the same abstract data type. But hash map implementations are distinct from treemap implementations in that one uses a hash table and one uses a binary search tree.</p>
<blockquote>
<p>Hashtable is a data structure that <strong>maps</strong> keys to values</p>
</blockquote>
<p>Going back to the drawer analogy, bins have a label rather than a number.</p>
<p><strong>HashMap is like a drawer that stores things on bins and labels them</strong></p>
<img src="/images/hashmap-drawer.jpg" class="" title="HashMap is like a drawer that stores things on bins and labels them">

<p>In this example, if you are looking for the book, you don’t have to open bin 1, 2, and 3. You go directly to the container labeled as “books”. That’s a huge gain! Search time goes from <em>O(n)</em> to <em>O(1)</em>.</p>
<p>In arrays, the data is referenced using a numeric index (relatively to the position). However, HashMaps uses labels that could be a string, number, Object, or anything. Internally, the HashMap uses an Array, and it maps the labels to array indexes using a <em>hash function</em>.</p>
<!-- http://apprize.info/javascript/20lessons/20lessons.files/image052.jpg -->

<p>There are at least two ways to implement hashmap:</p>
<ol>
<li><strong>Array</strong>: Using a hash function to map a key to the array index value. Worst: <code>O(n)</code>, Average: <code>O(1)</code></li>
<li><strong>Binary Search Tree</strong>: using a self-balancing binary search tree to look up for values (more on this later). Worst: <em><code>O(log n)</code></em>, Average: <em><code>O(log n)</code></em>.</li>
</ol>
<p>We will cover Trees &amp; Binary Search Trees, so don’t worry about it for now. The most common implementation of Maps is using an <strong>array</strong> and <code>hash</code> function. So, that’s the one we are going to focus on.</p>
<p><strong>HashMap implemented with an array</strong></p>
<img src="/images/hash-map.jpg" class="" title="HashMap: hash function translates keys into bucket (array) indexes">

<p>As you can see in the image, each key gets translated into a <strong>hash code</strong>. Since the array size is limited (e.g., 10), we have to loop through the available buckets using the modulus function. In the buckets, we store the key/value pair, and if there’s more than one, we use a collection to hold them.</p>
<p>Now, What do you think about covering each of the HashMap components in detail? Let’s start with the <strong>hash function</strong>.</p>
<h3 id="HashMap-vs-Array"><a href="#HashMap-vs-Array" class="headerlink" title="HashMap vs. Array"></a>HashMap vs. Array</h3><p>Why go through the trouble of converting the key into an index and not using an array directly, you might ask. The main difference is that Array’s index doesn’t have any relationship with the data. You have to know where your data is.</p>
<p>Let’s say you want to count how many times words are used in a text. How would you implement that?</p>
<ol>
<li>You can use two arrays (let’s call it <code>A</code> and <code>B</code>). One for storing the word and another for storing how many times they have seen (frequency).</li>
<li>You can use a HashMap. They <em><code>key</code></em> is the word, and the <em><code>value</code></em> is the word’s frequency.</li>
</ol>
<p>What is the runtime of approach #1 using <strong>two arrays</strong>? If we say, the number of words in the text is <em><code>n</code></em>. Then we have to <code>search</code> if the word in the array <code>A</code>  and then increment the value on array <code>B</code> matching that index. For every word on <code>n</code>, we have to test if it’s already on array <code>A</code>. This double loop leave use with a runtime of <code>O(n<sup>2</sup>)</code>.</p>
<p>What is the runtime of approach #2 using a <strong>HashMap</strong>? We iterate through each word on the text once and increment the value if there is something there or set it to 1 if that word is seen for the first time. The runtime would be <code>O(n)</code>, which is much more performant than approach #1.</p>
<p>Differences between HashMap and Array</p>
<ul>
<li>Search on an array is <em>O(n)</em> while on a HashMap is <em>O(1)</em></li>
<li>Arrays can have duplicate values, while HashMap cannot have duplicated keys (but they can have identical values.)</li>
<li>The Array has a key (index) that is always a number from 0 to max value, while in a HashMap, you have control of the key, and it can be whatever you want: number, string, or symbol.</li>
</ul>
<h3 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h3><p>The first step to implement a HashMap is to have a hash function. This function will map every key to its value.</p>
<blockquote>
<p>The <strong>perfect hash function</strong> is the one that for every key, it assigns a unique index.</p>
</blockquote>
<p>Ideal hashing algorithms allow <em>constant time</em> access/lookup. However, it’s hard to achieve a perfect hashing function in practice. You might have the case where two different keys yields on the same index, causing a <em>collision</em>.</p>
<p>Collisions in HashMaps are unavoidable when using an array-like underlying data structure. At some point, data that can’t fit in a HashMap will reuse data slots. One way to deal with collisions is to store multiple values in the same bucket using a linked list or another array (more on this later). When we try to access the key’s value and found various values, we iterate over the values <em>O(n)</em>. However, in most implementations, the hash adjusts the size dynamically to avoid too many collisions. We can say that the <strong>amortized</strong> lookup time is <em>O(1)</em>. We are going to explain what we mean by amortized runtime later in this post with an example.</p>
<h3 id="Naive-HashMap-implementation"><a href="#Naive-HashMap-implementation" class="headerlink" title="Naïve HashMap implementation"></a>Naïve HashMap implementation</h3><p><a id="NaiveHashMap"></a>
A simple (and bad) hash function would be this one:</p>
<figure class="highlight js"><figcaption><span>Naive HashMap Implementation</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/maps/hash-maps/hash-map-1.js">full code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(initialCapacity = 2) &#123;</span><br><span class="line">    <span class="built_in">this</span>.buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">this</span>.getIndex(key);</span><br><span class="line">    <span class="built_in">this</span>.buckets[index] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">this</span>.getIndex(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.buckets[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hash(key) &#123;</span><br><span class="line marked">    <span class="keyword">return</span> key.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getIndex(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> indexHash = <span class="built_in">this</span>.hash(key);</span><br><span class="line marked">    <span class="keyword">const</span> index = indexHash % <span class="built_in">this</span>.buckets.length;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We are using <code>buckets</code> rather than drawer/bins, but you get the idea :)</p>
<p>We have an initial capacity of 2 (two buckets). But, we want to store any number of elements on them. We use modulus <code>%</code> to loop through the number of available buckets.</p>
<p>Take a look at our hash function in line 18. We are going to talk about it in a bit. First, let’s use our new HashMap!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> hashMap = <span class="keyword">new</span> NaiveHashMap();</span><br><span class="line"></span><br><span class="line">hashMap.set(<span class="string">&#x27;cat&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;rat&#x27;</span>, <span class="number">7</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;dog&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;art&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hashMap.buckets);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  bucket #0: &lt;1 empty item&gt;,</span></span><br><span class="line"><span class="comment">  bucket #1: 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">assert.equal(hashMap.get(<span class="string">&#x27;art&#x27;</span>), <span class="number">8</span>); <span class="comment">// this one is ok</span></span><br><span class="line">assert.equal(hashMap.get(<span class="string">&#x27;cat&#x27;</span>), <span class="number">8</span>); <span class="comment">// got overwritten by art 😱</span></span><br><span class="line">assert.equal(hashMap.get(<span class="string">&#x27;rat&#x27;</span>), <span class="number">8</span>); <span class="comment">// got overwritten by art 😱</span></span><br><span class="line">assert.equal(hashMap.get(<span class="string">&#x27;dog&#x27;</span>), <span class="number">8</span>); <span class="comment">// got overwritten by art 😱</span></span><br></pre></td></tr></table></figure>

<p>This <code>Map</code> allows us to <code>set</code> a key and a value and then <code>get</code> the value using a <code>key</code>. The key part is the <code>hash</code> function. Let’s see multiple implementations to see how it affects the Map’s performance.</p>
<p>Can you tell what’s wrong with <code>NaiveHashMap</code> before expanding the answer below?</p>
<details>
 <summary>What is wrong with `NaiveHashMap` is that...</summary>

<p><br><br>
<strong>1)</strong> <strong>Hash function</strong> generates many duplicates. E.g.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="string">&#x27;cat&#x27;</span>) <span class="comment">// 3</span></span><br><span class="line">hash(<span class="string">&#x27;dog&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>This hash implementation will cause a lot of collisions.</p>
<p><br><br>
<strong>2)</strong> <strong>Collisions</strong> are not handled at all. Both <code>cat</code> and <code>dog</code> will overwrite each other on position 3 of the Array (bucket#1).</p>
<p><br><br>
<strong>3)</strong> <strong>Size of the Array</strong> even if we get a better hash function, we will get duplicates because the Array has a size of 3, which less than the number of elements that we want to fit. We want to have an initial capacity that is well beyond what we need to fit.</p>
</details>

<p>Did you guess any? ☝️</p>
<h3 id="Improving-Hash-Function"><a href="#Improving-Hash-Function" class="headerlink" title="Improving Hash Function"></a>Improving Hash Function</h3><blockquote>
<p>The primary purpose of a HashMap is to reduce the search/access time of an Array from <em><code>O(n)</code></em> to <em><code>O(1)</code></em>.</p>
</blockquote>
<p>For that, we need:</p>
<ol>
<li>A proper hash function that produces as few collisions as possible.</li>
<li>An array big enough to hold all the required values.</li>
</ol>
<p>Let’s give it another shot at our hash function. Instead of using the string’s length, let’s sum each character <a target="_blank" rel="noopener" href="https://simple.wikipedia.org/wiki/ASCII">ascii code</a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hash(key) &#123;</span><br><span class="line">  <span class="keyword">let</span> hashValue = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> stringKey = key.toString();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; stringKey.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> charCode = stringKey.charCodeAt(index);</span><br><span class="line">    hashValue += charCode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hashValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s try again:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="string">&#x27;cat&#x27;</span>) <span class="comment">// 312  (c=99 + a=97 + t=116)</span></span><br><span class="line">hash(<span class="string">&#x27;dog&#x27;</span>) <span class="comment">// 314 (d=100 + o=111 + g=103)</span></span><br></pre></td></tr></table></figure>
<p>This one is better! Because words with the same length have different codes.</p>
<p>Howeeeeeeeeever, there’s still an issue! Because <code>rat</code> and <code>art</code> are both 327, <strong>collision!</strong> 💥</p>
<p>We can fix that by offsetting the sum with the position:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hash(key) &#123;</span><br><span class="line">  <span class="keyword">let</span> hashValue = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> stringKey = <span class="string">`<span class="subst">$&#123;key&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; stringKey.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> charCode = stringKey.charCodeAt(index);</span><br><span class="line">    hashValue += charCode &lt;&lt; (index * <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hashValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s try again, this time with hex numbers so we can see the offset.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r = 114 or 0x72; a = 97 or 0x61; t = 116 or 0x74</span></span><br><span class="line">hash(<span class="string">&#x27;rat&#x27;</span>); <span class="comment">// 7,627,122 (r: 114 * 1 + a: 97 * 256 + t: 116 * 65,536) or in hex: 0x746172 (r: 0x72 + a: 0x6100 + t: 0x740000)</span></span><br><span class="line">hash(<span class="string">&#x27;art&#x27;</span>); <span class="comment">// 7,631,457 or 0x747261</span></span><br></pre></td></tr></table></figure>

<p>What about different types?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="number">1</span>); <span class="comment">// 49</span></span><br><span class="line">hash(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 49</span></span><br><span class="line"></span><br><span class="line">hash(<span class="string">&#x27;1,2,3&#x27;</span>); <span class="comment">// 741485668</span></span><br><span class="line">hash([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// 741485668</span></span><br><span class="line"></span><br><span class="line">hash(<span class="string">&#x27;undefined&#x27;</span>) <span class="comment">// 3402815551</span></span><br><span class="line">hash(<span class="literal">undefined</span>) <span class="comment">// 3402815551</span></span><br></pre></td></tr></table></figure>

<p>Houston, we still have a problem!! Different value types shouldn’t return the same hash code!</p>
<p>How can we solve that?</p>
<p>One way is taking into account the key <code>type</code> into the hash function.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hash(key) &#123;</span><br><span class="line">  <span class="keyword">let</span> hashValue = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> stringTypeKey = <span class="string">`<span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;<span class="keyword">typeof</span> key&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; stringTypeKey.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> charCode = stringTypeKey.charCodeAt(index);</span><br><span class="line">    hashValue += charCode &lt;&lt; (index * <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hashValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s test that again:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hash(<span class="number">1</span>)); <span class="comment">// 1843909523</span></span><br><span class="line"><span class="built_in">console</span>.log(hash(<span class="string">&#x27;1&#x27;</span>)); <span class="comment">// 1927012762</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hash(<span class="string">&#x27;1,2,3&#x27;</span>)); <span class="comment">// 2668498381</span></span><br><span class="line"><span class="built_in">console</span>.log(hash([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 2533949129</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hash(<span class="string">&#x27;undefined&#x27;</span>)); <span class="comment">// 5329828264</span></span><br><span class="line"><span class="built_in">console</span>.log(hash(<span class="literal">undefined</span>)); <span class="comment">// 6940203017</span></span><br></pre></td></tr></table></figure>

<p><a id="DecentHashMap"></a>
Yay!!! 🎉 We have a much better hash function!</p>
<p>We also can change the initial capacity of the Array to minimize collisions. Let’s put all of that together in the next section.</p>
<h3 id="Decent-HashMap-Implementation"><a href="#Decent-HashMap-Implementation" class="headerlink" title="Decent HashMap Implementation"></a>Decent HashMap Implementation</h3><p>Using our optimized hash function, we can now do much better.</p>
<p>We could still have collisions, so let’s implement something to handle them.</p>
<!-- However, it doesn't matter how good our hash function is. As long as we use a limited size bucket, we would have collisions.  So, we have to account for that and handle it gracefully.  -->

<p>Let’s make the following improvements to our HashMap implementation:</p>
<ul>
<li><strong>Hash function</strong> that checks types and character orders to minimize collisions.</li>
<li><strong>Handle collisions</strong> by appending values to a list. We also added a counter to keep track of them.</li>
</ul>
<figure class="highlight js"><figcaption><span>Decent HashMap Implementation</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/maps/hash-maps/hash-map-2.js">full code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecentHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(initialCapacity = 2) &#123;</span><br><span class="line">    <span class="built_in">this</span>.buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(initialCapacity);</span><br><span class="line">    <span class="built_in">this</span>.collisions = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> bucketIndex = <span class="built_in">this</span>.getIndex(key);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.buckets[bucketIndex]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.buckets[bucketIndex].push(&#123;key, value&#125;);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.buckets[bucketIndex].length &gt; <span class="number">1</span>) &#123; <span class="built_in">this</span>.collisions++; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.buckets[bucketIndex] = [&#123;key, value&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line marked"></span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> bucketIndex = <span class="built_in">this</span>.getIndex(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arrayIndex = <span class="number">0</span>; arrayIndex &lt; <span class="built_in">this</span>.buckets[bucketIndex].length; arrayIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> entry = <span class="built_in">this</span>.buckets[bucketIndex][arrayIndex];</span><br><span class="line marked">      <span class="keyword">if</span>(entry.key === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> entry.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hash(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> hashValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> stringTypeKey = <span class="string">`<span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;<span class="keyword">typeof</span> key&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; stringTypeKey.length; index++) &#123;</span><br><span class="line">      <span class="keyword">const</span> charCode = stringTypeKey.charCodeAt(index);</span><br><span class="line">      hashValue += charCode &lt;&lt; (index * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getIndex(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> indexHash = <span class="built_in">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">const</span> index = indexHash % <span class="built_in">this</span>.buckets.length;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Let’s use it and see how it perform:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> hashMap = <span class="keyword">new</span> DecentHashMap();</span><br><span class="line"></span><br><span class="line">hashMap.set(<span class="string">&#x27;cat&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;rat&#x27;</span>, <span class="number">7</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;dog&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;art&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;collisions: &#x27;</span>, hashMap.collisions); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(hashMap.buckets);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  bucket #0: [ &#123; key: &#x27;cat&#x27;, value: 2 &#125;, &#123; key: &#x27;art&#x27;, value: 8 &#125; ]</span></span><br><span class="line"><span class="comment">  bucket #1: [ &#123; key: &#x27;rat&#x27;, value: 7 &#125;, &#123; key: &#x27;dog&#x27;, value: 1 &#125; ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">assert.equal(hashMap.get(<span class="string">&#x27;art&#x27;</span>), <span class="number">8</span>); <span class="comment">// this one is ok</span></span><br><span class="line">assert.equal(hashMap.get(<span class="string">&#x27;cat&#x27;</span>), <span class="number">2</span>); <span class="comment">// Good. Didn&#x27;t got overwritten by art</span></span><br><span class="line">assert.equal(hashMap.get(<span class="string">&#x27;rat&#x27;</span>), <span class="number">7</span>); <span class="comment">// Good. Didn&#x27;t got overwritten by art</span></span><br><span class="line">assert.equal(hashMap.get(<span class="string">&#x27;dog&#x27;</span>), <span class="number">1</span>); <span class="comment">// Good. Didn&#x27;t got overwritten by art</span></span><br></pre></td></tr></table></figure>

<p>This <code>DecentHashMap</code> gets the job done, but there are still some issues. We are using a decent hash function that doesn’t produce duplicate values, and that’s great. However, we have two values in <code>bucket#0</code> and two more in <code>bucket#1</code>. How is that possible?</p>
<p>Since we are using a limited bucket size of 2, we use modulus <code>%</code> to loop through the number of available buckets. So, even if the hash code is different, all values will fit on the Array size: bucket#0 or bucket#1.</p>
<!-- [{"key":"cat","hash":3789411390},{"key":"dog","hash":3788563007},{"key":"rat","hash":3789411405},{"key":"art","hash":3789415740}] -->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="string">&#x27;cat&#x27;</span>) =&gt; <span class="number">3789411390</span>; <span class="function"><span class="params">bucketIndex</span> =&gt;</span> <span class="number">3789411390</span> % <span class="number">2</span> = <span class="number">0</span></span><br><span class="line">hash(<span class="string">&#x27;art&#x27;</span>) =&gt; <span class="number">3789415740</span>; <span class="function"><span class="params">bucketIndex</span> =&gt;</span> <span class="number">3789415740</span> % <span class="number">2</span> = <span class="number">0</span></span><br><span class="line">hash(<span class="string">&#x27;dog&#x27;</span>) =&gt; <span class="number">3788563007</span>; <span class="function"><span class="params">bucketIndex</span> =&gt;</span> <span class="number">3788563007</span> % <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">hash(<span class="string">&#x27;rat&#x27;</span>) =&gt; <span class="number">3789411405</span>; <span class="function"><span class="params">bucketIndex</span> =&gt;</span> <span class="number">3789411405</span> % <span class="number">2</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>So naturally, we have increased the initial capacity, but by how much? Let’s see how the initial size affects the hash map performance.</p>
<p>If we have an initial capacity of <code>1</code>. All the values will go into one bucket (<code>bucket#0</code>), and it won’t be any better than searching a deal in a simple array <em><code>O(n)</code></em>.</p>
<p>Let’s say that we start with an initial capacity set to 10:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hashMapSize10 = <span class="keyword">new</span> DecentHashMap(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">hashMapSize10.set(<span class="string">&#x27;cat&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">hashMapSize10.set(<span class="string">&#x27;rat&#x27;</span>, <span class="number">7</span>);</span><br><span class="line">hashMapSize10.set(<span class="string">&#x27;dog&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">hashMapSize10.set(<span class="string">&#x27;art&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;collisions: &#x27;</span>, hashMapSize10.collisions); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hashMapSize10\n&#x27;</span>, hashMapSize10.buckets);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  bucket#0: [ &#123; key: &#x27;cat&#x27;, value: 2 &#125;, &#123; key: &#x27;art&#x27;, value: 8 &#125; ],</span></span><br><span class="line"><span class="comment">            &lt;4 empty items&gt;,</span></span><br><span class="line"><span class="comment">  bucket#5: [ &#123; key: &#x27;rat&#x27;, value: 7 &#125; ],</span></span><br><span class="line"><span class="comment">            &lt;1 empty item&gt;,</span></span><br><span class="line"><span class="comment">  bucket#7: [ &#123; key: &#x27;dog&#x27;, value: 1 &#125; ],</span></span><br><span class="line"><span class="comment">            &lt;2 empty items&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Another way to see this</p>
<img src="/images/hash-map.jpg" class="" title="HashMap: hash function translates keys into bucket (array) indexes">

<p>As you can see, we reduced the number of collisions (from 2 to 1) by increasing the hash map’s initial capacity.</p>
<p>Let’s try with a bigger capacity 💯:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hashMapSize100 = <span class="keyword">new</span> DecentHashMap(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">hashMapSize100.set(<span class="string">&#x27;cat&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">hashMapSize100.set(<span class="string">&#x27;rat&#x27;</span>, <span class="number">7</span>);</span><br><span class="line">hashMapSize100.set(<span class="string">&#x27;dog&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">hashMapSize100.set(<span class="string">&#x27;art&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;collisions: &#x27;</span>, hashMapSize100.collisions); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hashMapSize100\n&#x27;</span>, hashMapSize100.buckets);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            &lt;5 empty items&gt;,</span></span><br><span class="line"><span class="comment">  bucket#5: [ &#123; key: &#x27;rat&#x27;, value: 7 &#125; ],</span></span><br><span class="line"><span class="comment">            &lt;1 empty item&gt;,</span></span><br><span class="line"><span class="comment">  bucket#7: [ &#123; key: &#x27;dog&#x27;, value: 1 &#125; ],</span></span><br><span class="line"><span class="comment">            &lt;32 empty items&gt;,</span></span><br><span class="line"><span class="comment">  bucket#41: [ &#123; key: &#x27;art&#x27;, value: 8 &#125; ],</span></span><br><span class="line"><span class="comment">            &lt;49 empty items&gt;,</span></span><br><span class="line"><span class="comment">  bucket#90: [ &#123; key: &#x27;cat&#x27;, value: 2 &#125; ],</span></span><br><span class="line"><span class="comment">            &lt;9 empty items&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>Yay! 🎊 no collision!</p>
<p>Having a bigger bucket size is excellent to avoid collisions, but it consumes <strong>too much memory</strong>, and probably most of the buckets will be unused.</p>
<p>Wouldn’t it be great if we can have a HashMap that automatically increases its size as needed? Well, that’s called ** rehash**, and we are going to do it next!</p>
<h3 id="Optimal-HashMap-Implementation"><a href="#Optimal-HashMap-Implementation" class="headerlink" title="Optimal HashMap Implementation"></a>Optimal HashMap Implementation</h3><p>If we have a big enough bucket, we won’t have collisions; thus, the search time would be <em><code>O(1)</code></em>. However, how do we know how big a hash map capacity should big? 100? 1,000? A million?</p>
<p>Having allocated massive amounts of memory is impractical. So, we can automatically have the hash map resize itself based on a load factor. This operation is called ** rehash**.</p>
<p>The <strong>load factor</strong> is the measurement of how full is a hash map. We can get the load factor by dividing the number of items by the bucket size.</p>
<p>This will be our latest and greatest hash map implementation:</p>
<!-- http://www.dcs.gla.ac.uk/~jsinger/pdfs/sicsa_openjdk/OpenJDKArchitecture.pdf -->
<!-- JDK10: https://github.com/dmlloyd/openjdk/blob/jdk/jdk/src/hotspot/share/utilities/hashtable.cpp -->
<!-- https://github.com/dmlloyd/openjdk/blob/jdk/jdk/src/java.desktop/windows/native/libawt/windows/Hashtable.h -->
<!-- https://github.com/dmlloyd/openjdk/blob/jdk/jdk/src/java.desktop/windows/native/libawt/windows/Hashtable.cpp -->

<!-- http://hg.openjdk.java.net/jdk10/master/file/6a0c42c40cd1/src/hotspot/share/utilities/hashtable.hpp -->
<!-- http://hg.openjdk.java.net/jdk10/master/file/6a0c42c40cd1/src/hotspot/share/utilities/hashtable.cpp -->

<!-- http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/f08705540498/src/java.base/share/classes/java/util/HashMap.java -->

<!-- http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/556b17038b5c/src/share/classes/java/util/HashMap.java -->
<!-- http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/556b17038b5c/src/share/classes/java/util/Hashtable.java -->


<!-- http://www.docjar.com/html/api/java/util/LinkedList.java.html -->
<!-- http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/tip/src/share/classes/java/util/LinkedList.java -->
<!-- https://algs4.cs.princeton.edu/13stacks/DoublyLinkedList.java.html -->

<p><a id="HashMapWithRehash"></a></p>
<details>
 <summary>**Optimized Hash Map Implementation _(click here to show the code)_**</summary>

<figure class="highlight js"><figcaption><span>Optimal HashMap Implementation</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/maps/hash-maps/hash-map.js">documented code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(initialCapacity = 16, loadFactor = 0.75) &#123;</span><br><span class="line">    <span class="built_in">this</span>.buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(initialCapacity);</span><br><span class="line marked">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.collisions = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.keys = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hash(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> hashValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> stringTypeKey = <span class="string">`<span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;<span class="keyword">typeof</span> key&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; stringTypeKey.length; index++) &#123;</span><br><span class="line">      <span class="keyword">const</span> charCode = stringTypeKey.charCodeAt(index);</span><br><span class="line">      hashValue += charCode &lt;&lt; (index * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  _getBucketIndex(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashValue = <span class="built_in">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">const</span> bucketIndex = hashValue % <span class="built_in">this</span>.buckets.length;</span><br><span class="line">    <span class="keyword">return</span> bucketIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;bucketIndex, entryIndex&#125; = <span class="built_in">this</span>._getIndexes(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(entryIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// initialize array and save key/value</span></span><br><span class="line">      <span class="keyword">const</span> keyIndex = <span class="built_in">this</span>.keys.push(&#123;<span class="attr">content</span>: key&#125;) - <span class="number">1</span>; <span class="comment">// keep track of the key index</span></span><br><span class="line">      <span class="built_in">this</span>.buckets[bucketIndex] = <span class="built_in">this</span>.buckets[bucketIndex] || [];</span><br><span class="line">      <span class="built_in">this</span>.buckets[bucketIndex].push(&#123;key, value, keyIndex&#125;);</span><br><span class="line">      <span class="built_in">this</span>.size++;</span><br><span class="line">      <span class="comment">// Optional: keep count of collisions</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.buckets[bucketIndex].length &gt; <span class="number">1</span>) &#123; <span class="built_in">this</span>.collisions++; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// override existing value</span></span><br><span class="line">      <span class="built_in">this</span>.buckets[bucketIndex][entryIndex].value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if a rehash is due</span></span><br><span class="line marked">    <span class="keyword">if</span>(<span class="built_in">this</span>.loadFactor &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.getLoadFactor() &gt; <span class="built_in">this</span>.loadFactor) &#123;</span><br><span class="line marked">      <span class="built_in">this</span>.rehash(<span class="built_in">this</span>.buckets.length * <span class="number">2</span>);</span><br><span class="line marked">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;bucketIndex, entryIndex&#125; = <span class="built_in">this</span>._getIndexes(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(entryIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.buckets[bucketIndex][entryIndex].value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="built_in">this</span>.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _getIndexes(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> bucketIndex = <span class="built_in">this</span>._getBucketIndex(key);</span><br><span class="line">    <span class="keyword">const</span> values = <span class="built_in">this</span>.buckets[bucketIndex] || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> entryIndex = <span class="number">0</span>; entryIndex &lt; values.length; entryIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> entry = values[entryIndex];</span><br><span class="line">      <span class="keyword">if</span>(entry.key === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;bucketIndex, entryIndex&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;bucketIndex&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;bucketIndex, entryIndex, keyIndex&#125; = <span class="built_in">this</span>._getIndexes(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(entryIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.buckets[bucketIndex].splice(entryIndex, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.keys[keyIndex];</span><br><span class="line">    <span class="built_in">this</span>.size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line marked">  rehash(newCapacity) &#123;</span><br><span class="line marked">    <span class="keyword">const</span> newMap = <span class="keyword">new</span> HashMap(newCapacity);</span><br><span class="line marked"></span><br><span class="line marked">    <span class="built_in">this</span>.keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line marked">      <span class="keyword">if</span>(key) &#123;</span><br><span class="line marked">        newMap.set(key.content, <span class="built_in">this</span>.get(key.content));</span><br><span class="line marked">      &#125;</span><br><span class="line marked">    &#125;);</span><br><span class="line marked"></span><br><span class="line marked">    <span class="comment">// update bucket</span></span><br><span class="line marked">    <span class="built_in">this</span>.buckets = newMap.buckets;</span><br><span class="line marked">    <span class="built_in">this</span>.collisions = newMap.collisions;</span><br><span class="line marked">    <span class="comment">// Optional: both `keys` has the same content except that the new one doesn&#x27;t have empty spaces from deletions</span></span><br><span class="line marked">    <span class="built_in">this</span>.keys = newMap.keys;</span><br><span class="line marked">  &#125;</span><br><span class="line"></span><br><span class="line marked">  getLoadFactor() &#123;</span><br><span class="line marked">    <span class="keyword">return</span> <span class="built_in">this</span>.size / <span class="built_in">this</span>.buckets.length;</span><br><span class="line marked">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p>Pay special attention to lines 96 to 114. That’s where the rehash magic happens. We create a new HashMap with doubled capacity.</p>
<p>So, <strong>testing</strong> our new implementation from above ^</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">assert.equal(hashMap.getLoadFactor(), <span class="number">0</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;songs&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;pets&#x27;</span>, <span class="number">7</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;tests&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;art&#x27;</span>, <span class="number">8</span>);</span><br><span class="line">assert.equal(hashMap.getLoadFactor(), <span class="number">4</span>/<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">hashMap.set(<span class="string">&#x27;Pineapple&#x27;</span>, <span class="string">&#x27;Pen Pineapple Apple Pen&#x27;</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;Despacito&#x27;</span>, <span class="string">&#x27;Luis Fonsi&#x27;</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;Bailando&#x27;</span>, <span class="string">&#x27;Enrique Iglesias&#x27;</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;Dura&#x27;</span>, <span class="string">&#x27;Daddy Yankee&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hashMap.set(<span class="string">&#x27;Lean On&#x27;</span>, <span class="string">&#x27;Major Lazer&#x27;</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Adele&#x27;</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;All About That Bass&#x27;</span>, <span class="string">&#x27;Meghan Trainor&#x27;</span>);</span><br><span class="line">hashMap.set(<span class="string">&#x27;This Is What You Came For&#x27;</span>, <span class="string">&#x27;Calvin Harris &#x27;</span>);</span><br><span class="line"></span><br><span class="line">assert.equal(hashMap.collisions, <span class="number">2</span>);</span><br><span class="line">assert.equal(hashMap.getLoadFactor(), <span class="number">0.75</span>);</span><br><span class="line">assert.equal(hashMap.buckets.length, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">hashMap.set(<span class="string">&#x27;Wake Me Up&#x27;</span>, <span class="string">&#x27;Avicii&#x27;</span>); <span class="comment">// &lt;--- Trigger REHASH</span></span><br><span class="line"></span><br><span class="line">assert.equal(hashMap.collisions, <span class="number">0</span>);</span><br><span class="line">assert.equal(hashMap.getLoadFactor(), <span class="number">0.40625</span>);</span><br><span class="line">assert.equal(hashMap.buckets.length, <span class="number">32</span>);</span><br></pre></td></tr></table></figure>

<p>Take notice that after we add the 12th item, the load factor gets beyond 0.75, so a rehash is triggered and doubles the capacity (from 16 to 32). Also, you can see how the number of collisions improves from 2 to 0!</p>
<p>This implementation is good enough to help us figure out the runtime of standard operations like insert/search/delete/edit.</p>
<p>To sum up, the performance of a HashMap will be given by:</p>
<ol>
<li>The hash function that every key produces for different output.</li>
<li>Size of the bucket to hold data.</li>
</ol>
<p>We nailed both 🔨. We have a decent hash function that produces different outputs for different data. Two distinct data will never return the same code. Also, we have a rehash function that automatically grows the capacity as needed. That’s great!</p>
<h3 id="Insert-element-on-a-HashMap-runtime"><a href="#Insert-element-on-a-HashMap-runtime" class="headerlink" title="Insert element on a HashMap runtime"></a>Insert element on a HashMap runtime</h3><p>Inserting an element on a HashMap requires two things: a key and a value. We could use our <a href="#DecentHashMap">DecentHashMap</a> data structure that we develop or use the built-in as follows:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">object, key, value</span>) </span>&#123;</span><br><span class="line">  object[key] = value;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(insert(hash, <span class="string">&#x27;word&#x27;</span>, <span class="number">1</span>)); <span class="comment">// =&gt; &#123; word: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>In modern JavaScript, you can use <code>Map</code>s.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertMap</span>(<span class="params">map, key, value</span>) </span>&#123;</span><br><span class="line">  map.set(key, value);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">console</span>.log(insertMap(map, <span class="string">&#x27;word&#x27;</span>, <span class="number">1</span>)); <span class="comment">// Map &#123; &#x27;word&#x27; =&gt; 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> We will use the <code>Map</code> rather than the regular <code>Object</code>, since the Map’s key could be anything while on Object’s key can only be string or number. Also, <code>Map</code>s keeps the order of insertion.</p>
<p>Behind the scenes, the <code>Map.set</code> just insert elements into an array (take a look at <a href="#DecentHashMap"><code>DecentHashMap.set</code></a>). So, similar to <code>Array.push</code> we have that:</p>
<blockquote>
<p>Insert an element in HashMap runtime is <em>O(1)</em>. If rehash is needed, then it will take <em>O(n)</em></p>
</blockquote>
<p>Our implementation with <a href="#HashMapWithRehash">rehash</a> functionality will keep collisions to the minimum. The rehash operation takes <em><code>O(n)</code></em>, but it doesn’t happen all the time, only when it is needed.</p>
<h3 id="Search-Access-an-element-on-a-HashMap-runtime"><a href="#Search-Access-an-element-on-a-HashMap-runtime" class="headerlink" title="Search/Access an element on a HashMap runtime"></a>Search/Access an element on a HashMap runtime</h3><p>This is the <code>HashMap.get</code> function that we use to get the value associated with a key. Let’s evaluate the implementation from <a href="#DecentHashMap"><code>DecentHashMap.get</code></a>):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">get(key) &#123;</span><br><span class="line">  <span class="keyword">const</span> hashIndex = <span class="built_in">this</span>.getIndex(key);</span><br><span class="line marked">  <span class="keyword">const</span> values = <span class="built_in">this</span>.array[hashIndex];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> entry = values[index];</span><br><span class="line">    <span class="keyword">if</span>(entry.key === key) &#123;</span><br><span class="line">      <span class="keyword">return</span> entry.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If there’s no collision, then <code>values</code> will only have one value, and the access time would be <em><code>O(1)</code></em>. But, we know there will be collisions. If the initial capacity is too small and the hash function is terrible like <a href="#NaiveHashMap">NaiveHashMap.hash</a>, then most of the elements will end up in a few buckets <em><code>O(n)</code></em>.</p>
<blockquote>
<p>HashMap access operation has a runtime of <em><code>O(1)</code></em> on average and worst-case of <em><code>O(n)</code></em>.</p>
</blockquote>
<p><strong>Advanced Note:</strong> Another idea to reduce the time to get elements from <em>O(n)</em> to <em>O(log n)</em> is to use a <em>binary search tree</em> instead of an array. Actually, <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/f08705540498/src/java.base/share/classes/java/util/HashMap.java#l145">Java’s HashMap implementation</a> switches from an array to a tree when a bucket has more than <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/f08705540498/src/java.base/share/classes/java/util/HashMap.java#l257">8 elements</a>.</p>
<h3 id="Edit-Delete-element-on-a-HashMap-runtime"><a href="#Edit-Delete-element-on-a-HashMap-runtime" class="headerlink" title="Edit/Delete element on a HashMap runtime"></a>Edit/Delete element on a HashMap runtime</h3><p>Editing (<code>HashMap.set</code>) and deleting (<code>HashMap.delete</code>) key/value pairs have an <strong>amortized</strong> runtime of <em><code>O(1)</code></em>. In the case of many collisions, we could face an <em><code>O(n)</code></em> as a worst-case. However, with our rehash operation, we can mitigate that risk.</p>
<blockquote>
<p>HashMap edits and delete operations has a runtime of <em><code>O(1)</code></em> on average and worst-case of <em><code>O(n)</code></em>.</p>
</blockquote>
<h3 id="HashMap-operations-time-complexity"><a href="#HashMap-operations-time-complexity" class="headerlink" title="HashMap operations time complexity"></a>HashMap operations time complexity</h3><p>We can sum up the arrays time complexity as follows:</p>
<p><strong>HashMap Time Complexities</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Worst</th>
<th>Amortized</th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td>Access/Search (<code>HashMap.get</code>)</td>
<td><em><code>O(n)</code></em></td>
<td><em><code>O(1)</code></em></td>
<td><em><code>O(n)</code></em> is an extreme case when there are too many collisions</td>
</tr>
<tr>
<td>Insert/Edit (<code>HashMap.set</code>)</td>
<td><em><code>O(n)</code></em></td>
<td><em><code>O(1)</code></em></td>
<td><em><code>O(n)</code></em> only happens with rehash when the Hash is 0.75 full</td>
</tr>
<tr>
<td>Delete (<code>HashMap.delete</code>)</td>
<td><em><code>O(n)</code></em></td>
<td><em><code>O(1)</code></em></td>
<td><em><code>O(n)</code></em> is an extreme case when there are too many collisions</td>
</tr>
</tbody></table>
<h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>Sets are very similar to arrays. The difference is that they don’t allow duplicates.</p>
<p>How can we implement a Set (Array without duplicates)? We could use an array and check if an element is there before inserting a new one. But the running time of checking if a value is already there is <em><code>O(n)</code></em>. Can we do better than that? We develop the <code>Map</code> with an amortized run time of <em><code>O(1)</code></em>!</p>
<!-- The best way to learn how something works is to implement it ourselves. We are also going to explore the built-in `Set` in JavaScript. -->

<h3 id="Set-Implementation"><a href="#Set-Implementation" class="headerlink" title="Set Implementation"></a>Set Implementation</h3><p>We could use the JavaScript built-in <code>Set</code>. However, if we implement it by ourselves, it’s more logical to deduct the runtimes. We are going to use the <a href="#HashMapWithRehash">optimized HashMap</a> with rehash functionality.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HashMap = <span class="built_in">require</span>(<span class="string">&#x27;../hash-maps/hash-map&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(value) &#123;</span><br><span class="line">    <span class="built_in">this</span>.hashMap.set(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.hashMap.has(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.hashMap.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.hashMap.delete(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  entries() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.hashMap.keys.reduce(<span class="function">(<span class="params">acc, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        acc.push(key.content);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> acc</span><br><span class="line">    &#125;, []);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We used <code>HashMap.set</code> to add the set elements without duplicates. We use the key as the value, and since the hash map’s keys are unique, we are all set.</p>
<p>Checking if an element is already there can be done using the <code>hashMap.has</code>, which has an amortized runtime of <em><code>O(1)</code></em>. Most operations would be an amortized constant time except for getting the <code>entries</code>, <em><code>O(n)</code></em>.</p>
<p>Note: The JS built-in <code>Set.has</code> has a runtime of <em>O(n)</em> since it uses a regular list of elements and checks each one at a time. You can see the <code>Set.has</code> algorithm <a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-set.prototype.has">here</a></p>
<p>Here some examples how to use it:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="comment">// const set = new Set(); // Using the built-in</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> MySet(); <span class="comment">// Using our own implementation</span></span><br><span class="line"></span><br><span class="line">set.add(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">set.add(<span class="string">&#x27;uno&#x27;</span>);</span><br><span class="line">set.add(<span class="string">&#x27;one&#x27;</span>); <span class="comment">// should NOT add this one twice</span></span><br><span class="line"></span><br><span class="line">assert.equal(set.has(<span class="string">&#x27;one&#x27;</span>), <span class="literal">true</span>);</span><br><span class="line">assert.equal(set.has(<span class="string">&#x27;dos&#x27;</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">assert.equal(set.size, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// assert.deepEqual(Array.from(set), [&#x27;one&#x27;, &#x27;uno&#x27;]);</span></span><br><span class="line"></span><br><span class="line">assert.equal(set.delete(<span class="string">&#x27;one&#x27;</span>), <span class="literal">true</span>);</span><br><span class="line">assert.equal(set.delete(<span class="string">&#x27;one&#x27;</span>), <span class="literal">false</span>);</span><br><span class="line">assert.equal(set.has(<span class="string">&#x27;one&#x27;</span>), <span class="literal">false</span>);</span><br><span class="line">assert.equal(set.size, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>You should be able to use <code>MySet</code> and the built-in <code>Set</code> interchangeably for these examples.</p>
<h3 id="Set-Operations-runtime"><a href="#Set-Operations-runtime" class="headerlink" title="Set Operations runtime"></a>Set Operations runtime</h3><p>From our Set implementation using a HashMap, we can sum up the time complexity as follows (very similar to the HashMap):</p>
<p><strong>Set Time Complexities</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Worst</th>
<th>Amortized</th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td>Access/Search (<code>Set.has</code>)</td>
<td><em><code>O(n)</code></em></td>
<td><em><code>O(1)</code></em></td>
<td><em><code>O(n)</code></em> is an extreme case when there are too many collisions</td>
</tr>
<tr>
<td>Insert/Edit (<code>Set.add</code>)</td>
<td><em><code>O(n)</code></em></td>
<td><em><code>O(1)</code></em></td>
<td><em><code>O(n)</code></em> only happens with <em>rehash</em> when the Hash is 0.75 full</td>
</tr>
<tr>
<td>Delete (<code>Set.delete</code>)</td>
<td><em><code>O(n)</code></em></td>
<td><em><code>O(1)</code></em></td>
<td><em><code>O(n)</code></em> is an extreme case when there are too many collisions</td>
</tr>
</tbody></table>
<h2 id="Linked-Lists"><a href="#Linked-Lists" class="headerlink" title="Linked Lists"></a>Linked Lists</h2><p>A linked list is a data structure where every element is connected to the next one.</p>
<img src="/images/linked-list.jpg" class="" title="LinkedList">

<p>The linked list is the first data structure that we are going to implement without using an array. Instead, we will use a <code>node</code> that holds a <code>value</code> and points to the next element.</p>
<figure class="highlight js"><figcaption><span>node.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When we have a chain of nodes where each one points to the next one, we a <strong>Singly Linked list</strong>.</p>
<h3 id="Singly-Linked-Lists"><a href="#Singly-Linked-Lists" class="headerlink" title="Singly Linked Lists"></a>Singly Linked Lists</h3><p>For a singly linked list, we only have to worry about every element referencing the next one.</p>
<p>We start by constructing the root or head element.</p>
<figure class="highlight js"><figcaption><span>linked-list.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>; <span class="comment">// first/head/root element</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span>; <span class="comment">// total number of elements in the list</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are four basic operations that we can do in every Linked List:</p>
<ol>
<li><code>addLast</code>: appends an element to the end of the list (tail)</li>
<li><code>removeLast</code>: deletes element to the end of the list</li>
<li><code>addFirst</code>: Adds an element to the beginning of the list (head)</li>
<li><code>removeFirst</code>: Removes an element from the start of the list (head/root)</li>
</ol>
<p><strong>Adding/Removing an element at the end of a linked list</strong></p>
<p>There are two primary cases:</p>
<ol>
<li>If the list first (root/head) doesn’t have any element yet, we make this node the head of the list.</li>
<li>Contrary, if the list already has items, then we have to iterate until finding the last one and appending our new node to the end.</li>
</ol>
<p><a id="SinglyLinkedList.addLast"></a></p>
<figure class="highlight js"><figcaption><span>LinkedList.prototype.addLast</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">addLast(value) &#123; <span class="comment">// similar Array.push</span></span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.root) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span>(currentNode &amp;&amp; currentNode.next) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What’s the runtime of this code? If it is the first element, then adding to the root is <em>O(1)</em>. However, finding the last item is <em>O(n)</em>.</p>
<p>Now, removing an element from the end of the list has a similar code. We have to find the current before last and make its <code>next</code> reference <code>null</code>.</p>
<p><a id="SinglyLinkedList.removeLast"></a></p>
<figure class="highlight js"><figcaption><span>LinkedList.prototype.removeLast</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">removeLast() &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.root;</span><br><span class="line">  <span class="keyword">let</span> target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(current &amp;&amp; current.next) &#123;</span><br><span class="line">    <span class="keyword">while</span>(current &amp;&amp; current.next &amp;&amp; current.next.next) &#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    target = current.next;</span><br><span class="line marked">    current.next = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    target = current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The runtime again is <em>O(n)</em> because we have to iterate until the second-last element and remove the reference to the last (line 10).</p>
<p><strong>Adding/Removing an element from the beginning of a linked list</strong></p>
<p><a id="SinglyLinkedList.removeFirst"></a></p>
<p>Adding an element to the head of the list is like this:</p>
<figure class="highlight js"><figcaption><span>LinkedList.addFirst</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Adds an element to the beginning of the list. Similar to Array.unshift</span></span><br><span class="line"><span class="comment">  * Runtime: O(1)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">addFirst(value) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> Node(value);</span><br><span class="line">  node.next = <span class="built_in">this</span>.root;</span><br><span class="line">  <span class="built_in">this</span>.root = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Adding and removing elements from the beginning is a constant time because we hold a reference to the first element:</p>
<figure class="highlight js"><figcaption><span>LinkedList.removeFirst</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Removes element from the start of the list (head/root). It&#x27;s Similar `Array.shift`</span></span><br><span class="line"><span class="comment">  * Runtime: O(1)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">removeFirst() &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="built_in">this</span>.root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = first.next;</span><br><span class="line">    <span class="keyword">return</span> first.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As expected, the runtime for removing/adding to the first element from a linked List is always constant <em>O(1)</em></p>
<p><a id="LinkedList.remove"></a></p>
<p><strong>Removing an element anywhere from a linked list</strong></p>
<p>Removing an element anywhere in the list leverage the <code>removeLast</code> and <code>removeFirst</code>. However, if the removal is in the middle, then we assign the previous node to the next one. That removes any reference from the current node, this is removed from the list:</p>
<figure class="highlight js"><figcaption><span>LinkedList.remove</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">remove(index = <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line marked">    <span class="keyword">return</span> <span class="built_in">this</span>.removeFirst();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> current = <span class="built_in">this</span>.first, i = <span class="number">0</span>; current;  i++, current = current.next) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i === index) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!current.next) &#123; <span class="comment">// if it doesn&#x27;t have next it means that it is the last</span></span><br><span class="line marked">        <span class="keyword">return</span> <span class="built_in">this</span>.removeLast();</span><br><span class="line">      &#125;</span><br><span class="line marked">      current.previous.next = current.next;</span><br><span class="line">      <span class="built_in">this</span>.size--;</span><br><span class="line">      <span class="keyword">return</span> current.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that <code>index</code> is a zero-based index: 0 will be the first element, 1 second, and so on.</p>
<blockquote>
<p>Removing an element anywhere within the list is <em>O(n)</em>.</p>
</blockquote>
<p><a id="LinkedList.contains"></a></p>
<p><strong>Searching for an element in a linked list</strong></p>
<p>Searching an element on the linked list is very somewhat similar to <code>remove</code>:</p>
<figure class="highlight js"><figcaption><span>LinkedList.contains</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contains(value) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> current = <span class="built_in">this</span>.first, index = <span class="number">0</span>; current;  index++, current = current.next) &#123;</span><br><span class="line">    <span class="keyword">if</span>(current.value === value) &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function finds the first element with the given value.</p>
<blockquote>
<p>The runtime for searching an element in a linked list is <em>O(n)</em></p>
</blockquote>
<h3 id="Singly-Linked-Lists-time-complexity"><a href="#Singly-Linked-Lists-time-complexity" class="headerlink" title="Singly Linked Lists time complexity"></a>Singly Linked Lists time complexity</h3><p>Singly Linked List time complexity per function is as follows.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Runtime</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#DoublyLinkedList.addFirst"><code>addFirst</code></a></td>
<td><em>O(1)</em></td>
<td>Insert element to the beginning of the list</td>
</tr>
<tr>
<td><a href="#SinglyLinkedList.addLast"><code>addLast</code></a></td>
<td><em>O(n)</em></td>
<td>Insert element to the end of the list</td>
</tr>
<tr>
<td><a href="#DoublyLinkedList.add"><code>add</code></a></td>
<td><em>O(n)</em></td>
<td>Insert element anywhere in the list.</td>
</tr>
<tr>
<td><a href="#DoublyLinkedList.removeFirst"><code>removeFirst</code></a></td>
<td><em>O(1)</em></td>
<td>Remove element to the beginning of the list</td>
</tr>
<tr>
<td><a href="#SinglyLinkedList.removeLast"><code>removeLast</code></a></td>
<td><em>O(n)</em></td>
<td>Remove element to the end of the list</td>
</tr>
<tr>
<td><a href="#LinkedList.remove"><code>remove</code></a></td>
<td><em>O(n)</em></td>
<td>Remove any element from the list</td>
</tr>
<tr>
<td><a href="#LinkedList.contains"><code>contains</code></a></td>
<td><em>O(n)</em></td>
<td>Search for an element from the list</td>
</tr>
</tbody></table>
<p>Notice that every time we add/remove from the last position, the operation takes <em>O(n)</em>.</p>
<blockquote>
<p>But we could reduce the <code>addLast</code>/<code>removeLast</code> from <em>O(n)</em> to a flat <em>O(1)</em> if we keep a reference of the last element!</p>
</blockquote>
<p>We are going to add the last reference in the next section!</p>
<h3 id="Doubly-Linked-Lists"><a href="#Doubly-Linked-Lists" class="headerlink" title="Doubly Linked Lists"></a>Doubly Linked Lists</h3><p>When we have a chain of nodes where each one points to the next one, we have a <strong>Singly Linked list</strong>. When we have a linked list where each node leads to the <strong>next</strong> and the <strong>previous</strong> element, we have a <strong>Doubly Linked List</strong></p>
<img src="/images/doubly-linked-list.jpg" class="" title="Doubly Linked List">

<p>Doubly linked list nodes have double references (next and previous). We are also going to keep track of the list first and the last element.</p>
<figure class="highlight js"><figcaption><span>Doubly Linked List</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/linked-lists/linked-list.js">full code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.previous = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.first = <span class="literal">null</span>; <span class="comment">// head/root element</span></span><br><span class="line">    <span class="built_in">this</span>.last = <span class="literal">null</span>; <span class="comment">// last element of the list</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span>; <span class="comment">// total number of elements in the list</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Adding and Removing from the start of a list</strong></p>
<p>Adding and removing from the start of the list is simple since we have <code>this.first</code> reference:</p>
<p><a id="DoublyLinkedList.addFirst"></a></p>
<figure class="highlight js"><figcaption><span>LinkedList.prototype.addFirst</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/linked-lists/linked-list.js">full code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">addFirst(value) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">  node.next = <span class="built_in">this</span>.first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.first) &#123;</span><br><span class="line">    <span class="built_in">this</span>.first.previous = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.last = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.first = node; <span class="comment">// update head</span></span><br><span class="line">  <span class="built_in">this</span>.size++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that we have to be very careful and update the previous and last reference.</p>
<p><a id="DoublyLinkedList.removeFirst"></a></p>
<figure class="highlight js"><figcaption><span>LinkedList.prototype.removeFirst</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/linked-lists/linked-list.js">full code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">removeFirst() &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="built_in">this</span>.first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(first) &#123;</span><br><span class="line">    <span class="built_in">this</span>.first = first.next;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.first) &#123;</span><br><span class="line">      <span class="built_in">this</span>.first.previous = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first.value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.last = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What’s the runtime?</p>
<blockquote>
<p>Adding and removing elements from a (singly/doubly) LinkedList has a constant runtime <em>O(1)</em></p>
</blockquote>
<p><strong>Adding and removing from the end of a list</strong></p>
<p>Adding and removing <em>from the end</em> of the list is a little tricky. If you checked in the Singly Linked List, both operations took <em>O(n)</em> since we had to loop through the list to find the last element. Now, we have the <code>last</code> reference:</p>
<p><a id="DoublyLinkedList.addLast"></a></p>
<figure class="highlight js"><figcaption><span>LinkedList.prototype.addLast</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/linked-lists/linked-list.js">full code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">addLast(value) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.first) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.first;</span><br><span class="line">    node.previous = <span class="built_in">this</span>.last;</span><br><span class="line marked">    <span class="built_in">this</span>.last.next = node;</span><br><span class="line">    <span class="built_in">this</span>.last = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.first = node;</span><br><span class="line">    <span class="built_in">this</span>.last = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.size++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Again, we have to be careful about updating the references and handling exceptional cases such as only one element.</p>
<p><a id="DoublyLinkedList.removeLast"></a></p>
<figure class="highlight js"><figcaption><span>LinkedList.prototype.removeLast</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/linked-lists/linked-list.js">full code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">removeLast() &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.first;</span><br><span class="line">  <span class="keyword">let</span> target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(current &amp;&amp; current.next) &#123;</span><br><span class="line marked">    current = <span class="built_in">this</span>.last.previous;</span><br><span class="line">    <span class="built_in">this</span>.last = current;</span><br><span class="line">    target = current.next;</span><br><span class="line">    current.next = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.first = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.last = <span class="literal">null</span>;</span><br><span class="line">    target = current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(target) &#123;</span><br><span class="line">    <span class="built_in">this</span>.size--;</span><br><span class="line">    <span class="keyword">return</span> target.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using a doubly-linked list, we no longer have to iterate through the whole list to get the 2nd last element. We can use directly <code>this.last.previous</code> and is <code>O(1)</code>.</p>
<p>Did you remember that for the Queue, we had to use two arrays? We can now change that implementation and use a doubly-linked list instead. The runtime will be <em>O(1)</em> for insert at the start and deleting at the end.</p>
<p><a id="DoublyLinkedList.add"></a></p>
<p><strong>Adding an element anywhere from a linked list</strong></p>
<p>Adding an element on anywhere on the list leverages our <code>addFirst</code> and <code>addLast</code> functions as you can see below:</p>
<figure class="highlight js"><figcaption><span>LinkedList.add</span><a target="_blank" rel="noopener" href="https://github.com/amejiarosario/dsa.js/blob/master/src/data-structures/linked-lists/linked-list.js">FullCode</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">add(value, index = <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line marked">    <span class="keyword">return</span> <span class="built_in">this</span>.addFirst(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> current = <span class="built_in">this</span>.first, i = <span class="number">0</span>; i &lt;= <span class="built_in">this</span>.size;  i++, current = (current &amp;&amp; current.next)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i === index) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i === <span class="built_in">this</span>.size) &#123; <span class="comment">// if it doesn&#x27;t have next it means that it is the last</span></span><br><span class="line marked">        <span class="keyword">return</span> <span class="built_in">this</span>.addLast(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">      newNode.previous = current.previous;</span><br><span class="line">      newNode.next = current;</span><br><span class="line"></span><br><span class="line">      current.previous.next = newNode;</span><br><span class="line">      <span class="keyword">if</span>(current.next) &#123; current.next.previous = newNode; &#125;</span><br><span class="line">      <span class="built_in">this</span>.size++;</span><br><span class="line">      <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we have an insertion in the middle of the Array, then we have to update the <code>next</code> and <code>previous</code> reference of the surrounding elements.</p>
<blockquote>
<p>Adding an element anywhere within the list is <em>O(n)</em>.</p>
</blockquote>
<h3 id="Doubly-Linked-Lists-time-complexity"><a href="#Doubly-Linked-Lists-time-complexity" class="headerlink" title="Doubly Linked Lists time complexity"></a>Doubly Linked Lists time complexity</h3><p>Doubly Linked List time complexity per function is as follows:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Runtime</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#DoublyLinkedList.addFirst"><code>addFirst</code></a></td>
<td><em>O(1)</em></td>
<td>Insert element to the beginning of the list.</td>
</tr>
<tr>
<td><a href="#DoublyLinkedList.addLast"><code>addLast</code></a></td>
<td><em>O(1)</em></td>
<td>Insert element to the end of the list.</td>
</tr>
<tr>
<td><a href="#DoublyLinkedList.add"><code>add</code></a></td>
<td><em>O(n)</em></td>
<td>Insert element anywhere in the list.</td>
</tr>
<tr>
<td><a href="#DoublyLinkedList.removeFirst"><code>removeFirst</code></a></td>
<td><em>O(1)</em></td>
<td>Remove element to the beginning of the list.</td>
</tr>
<tr>
<td><a href="#DoublyLinkedList.removeLast"><code>removeLast</code></a></td>
<td><em>O(1)</em></td>
<td>Remove element to the end of the list.</td>
</tr>
<tr>
<td><a href="#LinkedList.remove"><code>remove</code></a></td>
<td><em>O(n)</em></td>
<td>Remove any element from the list</td>
</tr>
<tr>
<td><a href="#LinkedList.contains"><code>contains</code></a></td>
<td><em>O(n)</em></td>
<td>Search for any element from the list</td>
</tr>
</tbody></table>
<p>Doubly linked lists are a significant improvement compared to the singly linked list! We improved from <em>O(n)</em> to <em>O(1)</em> by:</p>
<ul>
<li>Adding a reference to the previous element.</li>
<li>Holding a reference to the last item in the list.</li>
</ul>
<p>Removing first/last can be done in constant time; however, eliminating in the middle of the Array is still <em>O(n)</em>.</p>
<h2 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h2><!-- https://docs.oracle.com/javase/10/docs/api/java/util/Stack.html -->

<p>Stacks is a data structure where the last entered data is the first to come out. Also know as Last-in, First-out (LIFO).</p>
<img src="/images/stack.jpg" class="" title="Stack: push and pop">

<p>Let’s implement a stack from scratch!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.input = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="built_in">this</span>.input.push(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.input.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, it is easy since we are using the built-in <code>Array.push</code> and <code>Array.pop</code>. Both have a runtime of <em><code>O(1)</code></em>.</p>
<p>Let’s see some examples of its usage:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">stack.push(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">stack.push(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">stack.push(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">stack.pop(); <span class="comment">// c</span></span><br><span class="line">stack.pop(); <span class="comment">// b</span></span><br><span class="line">stack.pop(); <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p>The first element in (<code>a</code>) is the last to get out. We can also implement Stack using a linked list instead of an array. The runtime will be the same.</p>
<p>That’s all!</p>
<h2 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h2><!-- https://docs.oracle.com/javase/10/docs/api/java/util/Queue.html -->
<!-- https://stackoverflow.com/a/22615787/684957 -->

<p>Queues are a data structure where the first data to get in is also the first to go out. A.k.a First-in, First-out (FIFO).
It’s like a line of people at the movies, the first to come in is the first to come out.</p>
<img src="/images/queue.jpg" class="" title="Queue: enqueue and dequeue">

<p>We could implement a Queue using an array, very similar to how we implemented the Stack.</p>
<h3 id="Queue-implemented-with-Array-s"><a href="#Queue-implemented-with-Array-s" class="headerlink" title="Queue implemented with Array(s)"></a>Queue implemented with Array(s)</h3><p>A naive implementation would be this one using <code>Array.push</code> and <code>Array.shift</code>:</p>
<p><a id="QueueNaiveImpl"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.input = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(element) &#123;</span><br><span class="line">    <span class="built_in">this</span>.input.push(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.input.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What’s the time complexity of <code>Queue.add</code> and <code>Queue.remove</code>?</p>
<ul>
<li><code>Queue.add</code> uses <code>array.push</code> which has a constant runtime. Win!</li>
<li><code>Queue.remove</code> uses <code>array.shift</code> which has a linear runtime. Can we do better than <em><code>O(n)</code></em>?</li>
</ul>
<p>Think of how you can implement a Queue only using <code>Array.push</code> and <code>Array.pop</code>.</p>
<p><a id="QueueArrayImpl"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.input = [];</span><br><span class="line">    <span class="built_in">this</span>.output = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(element) &#123;</span><br><span class="line">    <span class="built_in">this</span>.input.push(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove() &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.output.length) &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">this</span>.input.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.output.push(<span class="built_in">this</span>.input.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.output.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we are using two arrays rather than one.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">queue.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">queue.add(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">queue.remove() <span class="comment">// a</span></span><br><span class="line">queue.add(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">queue.remove() <span class="comment">// b</span></span><br><span class="line">queue.remove() <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>When we remove something for the first time, the <code>output</code> array is empty. So, we insert the content of <code>input</code> backward like <code>[&#39;b&#39;, &#39;a&#39;]</code>. Then we pop elements from the <code>output</code> array. As you can see, using this trick, we get the output in the same order of insertion (FIFO).</p>
<p>What’s the runtime?</p>
<p>If the output already has some elements, then the remove operation is constant <em><code>O(1)</code></em>. When the output arrays need to get refilled, it takes <em><code>O(n)</code></em> to do so. After the refilled, every operation would be constant again. The amortized time is <em><code>O(1)</code></em>.</p>
<p>We can achieve a <code>Queue</code> with a pure constant if we use LinkedList. Let’s see what it is in the next section!</p>
<!-- **[[usages]]** -->

<h3 id="Queue-implemented-with-a-Doubly-Linked-List"><a href="#Queue-implemented-with-a-Doubly-Linked-List" class="headerlink" title="Queue implemented with a Doubly Linked List"></a>Queue implemented with a Doubly Linked List</h3><p>We can achieve the best performance for a <code>queue</code> using a linked list rather than an array.</p>
<p><a id="QueueListImpl"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LinkedList = <span class="built_in">require</span>(<span class="string">&#x27;../linked-lists/linked-list&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.input = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(element) &#123;</span><br><span class="line">    <span class="built_in">this</span>.input.addFirst(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.input.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.input.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using a doubly-linked list with the last element reference, we achieve an <code>add</code> of <em>O(1)</em>. That’s the importance of using the right tool for the right job. 💪</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>We explored most of the linear data structures. We saw that depending on how we implement the data structures. There are different runtimes.</p>
<p>Here’s a summary of everything that we explored. You can click on each runtime, and it will take you to the implementation.</p>
<!-- there is not a generic runtime for the operations because it depends more  -->

<p><strong>Time complexity</strong></p>
<p><em>Click on the <strong>name</strong> to go to the section or click on the <strong>runtime</strong> to go to the implementation</em></p>
<p><code>*</code> = Amortized runtime</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Insert</th>
<th>Access</th>
<th>Search</th>
<th>Delete</th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#Array">Array</a></td>
<td><a href="#Insert-element-on-an-array">O(n)</a></td>
<td><a href="#Access-an-element-in-an-array">O(1)</a></td>
<td><a href="#Search-an-element-in-an-array">O(n)</a></td>
<td><a href="#Deleting-elements-from-an-array">O(n)</a></td>
<td>Insertion to the end is <code>O(1)</code>. <a href="#Array-operations-time-complexity">Details here.</a></td>
</tr>
<tr>
<td><a href="#HashMaps">HashMap</a></td>
<td><a href="#Insert-element-on-a-HashMap-runtime">O(1)</a></td>
<td><a href="#Search-Access-an-element-on-a-HashMap-runtime">O(1)</a></td>
<td><a href="#Search-Access-an-element-on-a-HashMap-runtime">O(1)</a></td>
<td><a href="#Edit-Delete-element-on-a-HashMap-runtime">O(1)</a></td>
<td>Rehashing might affect insertion time. <a href="#HashMap-operations-time-complexity">Details here.</a></td>
</tr>
<tr>
<td>Map (using Binary Search Tree)</td>
<td>O(log(n))</td>
<td>-</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td><a href="#Sets">Set (using HashMap)</a></td>
<td><a href="#Set-Implementation">O(1)</a></td>
<td>-</td>
<td><a href="#Set-Implementation">O(1)</a></td>
<td><a href="#Set-Implementation">O(1)</a></td>
<td>Set using a HashMap implementation. <a href="#Set-Operations-runtime">Details here.</a></td>
</tr>
<tr>
<td>Set (using list)</td>
<td><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-set.prototype.add">O(n)</a></td>
<td>-</td>
<td><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-set.prototype.has">O(n)</a></td>
<td><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-set.prototype.delete">O(n)</a></td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td>Set (using Binary Search Tree)</td>
<td>O(log(n))</td>
<td>-</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td><a href="#Singly-Linked-Lists">Linked List (singly)</a></td>
<td><a href="#SinglyLinkedList.addLast">O(n)</a></td>
<td>-</td>
<td><a href="#LinkedList.contains">O(n)</a></td>
<td><a href="#LinkedList.remove">O(n)</a></td>
<td>Adding/Removing to the start of the list is <code>O(1)</code>. <a href="#Singly-Linked-Lists-time-complexity">Details here</a>.</td>
</tr>
<tr>
<td><a href="#Doubly-Linked-Lists">Linked List (doubly)</a></td>
<td><a href="#DoublyLinkedList.add">O(n)</a></td>
<td>-</td>
<td><a href="#LinkedList.contains">O(n)</a></td>
<td><a href="#LinkedList.remove">O(n)</a></td>
<td>Adding/Deleting from the beginning/end is <code>O(1)</code>. But, deleting/adding from the middle is <code>O(n)</code>. <a href="#Doubly-Linked-Lists-time-complexity">Details here</a></td>
</tr>
<tr>
<td><a href="#Stacks">Stack (array implementation)</a></td>
<td><a href="#Stacks">O(1)</a></td>
<td>-</td>
<td>-</td>
<td><a href="#Stacks">O(1)</a></td>
<td>Insert/delete is last-in, first-out (LIFO)</td>
</tr>
<tr>
<td><a href="#QueueNaiveImpl">Queue (naïve array impl.)</a></td>
<td><a href="#QueueNaiveImpl">O(1)</a></td>
<td>-</td>
<td>-</td>
<td><a href="#QueueNaiveImpl">O(n)</a></td>
<td>Remove (<code>Array.shift</code>) is <em>O(n)</em></td>
</tr>
<tr>
<td><a href="#QueueArrayImpl">Queue (array implementation)</a></td>
<td><a href="#QueueArrayImpl">O(1)</a></td>
<td>-</td>
<td>-</td>
<td><a href="#QueueArrayImpl">O(1)</a></td>
<td>Worst time insert is O(n). However amortized is O(1)</td>
</tr>
<tr>
<td><a href="#QueueListImpl">Queue (list implementation)</a></td>
<td><a href="#QueueListImpl">O(1)</a></td>
<td>-</td>
<td>-</td>
<td><a href="#QueueListImpl">O(1)</a></td>
<td>Using Doubly Linked List with reference to the last element.</td>
</tr>
</tbody></table>
<p>Note: <strong>Binary search trees</strong> and trees, in general, will be cover in the next post. Also, graph data structures.</p>
<!-- Links

http://bigocheatsheet.com/

http://cooervo.github.io/Algorithms-DataStructures-BigONotation/

https://medium.freecodecamp.org/time-is-complex-but-priceless-f0abd015063c

https://code.tutsplus.com/tutorials/data-structures-with-javascript-whats-a-data-structure--cms-23347


Arrays:

Time complexity table for Arrays and dynamic DS
https://en.wikipedia.org/wiki/Linked_list#Linked_lists_vs._dynamic_arrays

JavaScript runtime complexity of Array functions
https://stackoverflow.com/a/22615787/684957


Backlinks:

https://www.reddit.com/r/compsci/comments/8m1dx0/data_structures_for_beginners_arrays_hashmaps_and/

https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/
2、各种数据结构的 JavaScript 实现（英文）

https://www.yuque.com/ruanyf/share/issue-10
-->

      </div>

      <!-- after post -->
      <div class="hidden-mobile-down">
        <h3>Now, your turn!</h3>
        Thanks for reading this far. Here are some things you can do next:

        <ul>
          <li>Found a typo?
            <a target="_blank" rel="noopener" href="https://github.com/amejiarosario/amejiarosario.github.io/edit/source/source/_posts/2018-05-25-Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial.md">
              Edit this post</a>.
          </li>
          <li>Got questions?
            <a href="#comments-section">comment</a>
            below.
          </li>
          <li>
            Was it useful? Show your
            <!-- <a href="/support">support</a>  -->
            support and share it.
            <!-- <a target="_blank" href="http://paypal.me/amejiarosario">Paypal</a>, -->
            <!-- <a target="_blank" href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=HZLFWQAFENN7W&source=url">Paypal</a>,
            <a target="_blank" href="https://bitaps.com/3A8xanut3wddz1jJ7JWSw8nwwpUahLJpZi">Bitcoin</a>,
            <a target="_blank" href="https://www.patreon.com/amejiarosario">Patreon</a>. -->
          </li>
        </ul>
      </div>

      <div class="hidden-mobile-up">
        <a target="_blank" rel="noopener" href="https://books.adrianmejia.com">
          <!-- <img src="/images/data-structure-algorithms-javascript-presell.jpg" alt="Data Structure and Algorithms in JavaScript eBook"> -->
          <img src="/images/data-structure-algorithms-banner.jpg" alt="Data Structure and Algorithms in JavaScript eBook">
        </a>
      </div>

      <!-- Next and previous posts -->
      
        <div class="article-nav m-y-4">
          
            <a href="/Data-Structures-for-Beginners-Graphs-Time-Complexity-tutorial/" class="article-nav-newer" class="article-nav-link-wrap">
              <strong class="article-nav-caption"><i class="fa fa-chevron-left"></i> newer</strong>
              <div class="article-nav-title">
                
                  Graph Data Structures in JavaScript for Beginners
                
              </div>
            </a>
          
          
            <a href="/Analysis-of-Recursive-Algorithms/" class="article-nav-older" class="article-nav-link-wrap">
              <strong class="article-nav-caption">older <i class="fa fa-chevron-right"></i></strong>
              <div class="article-nav-title">Analysis of Recursive Algorithms</div>
            </a>
          
        </div>
      

      

        <!-- Related -->
        <footer>
          <!-- subscribe -->
          <div class="m-y-4">
            <!-- Begin MailChimp Signup Form -->
<link href="//cdn-images.mailchimp.com/embedcode/horizontal-slim-10_7.css" rel="stylesheet" type="text/css">
<style type="text/css">
	#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; width:100%;}
	/* Add your own MailChimp form style overrides in your site stylesheet or in this style block.
	   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
</style>
<div id="mc_embed_signup">
<form action="//adrianmejia.us2.list-manage.com/subscribe/post?u=2294bb28c5931a6f2338d2474&amp;id=52678e825b" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" novalidate>
    <div id="mc_embed_signup_scroll">
	<label for="mce-EMAIL">Subscribe &amp; stay up to date!</label>
	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_2294bb28c5931a6f2338d2474_52678e825b" tabindex="-1" value=""></div>
    <div class="clear">&nbsp;<input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>
<!--End mc_embed_signup-->

<script type="text/javascript">
  var form = document.getElementById('mc-embedded-subscribe-form');
  form.addEventListener('submit', function(event) {
    event.preventDefault();
    ga('send', 'event', 'newsletter', 'signup', 'page', {
      hitCallback: createFunctionWithTimeout(function() {
        form.submit();
      })
    });
  });
</script>

          </div>

          <!-- Author Bio -->
          <b>About the author</b>
          
              <!-- Adrian Mejia Bio -->
            
<section class="bio-box">
  <img class="m-a-1 not-scaled" src="/images/adrian-mejia-headshot.png" alt="Adrian Mejia">
  <article class="p-x-1" style="display: flex; flex-direction:column;">
    <p class="muted">Adrian Mejia is a Software Engineer located in Boston, MA.
      Currently working at Google.
      Adrian enjoys writing posts about Algorithms, programming, JavaScript, and Web Dev.
      Also, he likes to travel ✈️ and biking 🚴‍.
      <!-- Find out more <a href="/#about">here</a>. -->
    </p>
    <!-- <p class="m-y-0"><a target="_blank" rel="noopener" href="https://twitter.com/iAmAdrianMejia">Follow him on Twitter</a>.</p> -->
    <a target="_blank" rel="noopener" href="https://twitter.com/iAmAdrianMejia" id="twitter-follow-button" class="twitter-follow-button" data-show-count="false">Follow @iAmAdrianMejia</a>&nbsp;
  </article>
</section>

          

          <div class="m-y-4">
            
              
                <div class="container">
                <h1 class="capitalize">tutorial algorithms Series</h1>
                <div class="row">
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/how-to-find-time-complexity-of-an-algorithm-code-big-o-notation/">
    
      <img src="/images/from-code-to-big-o-algorithms-small.png" width="300" height="250">
      <section class="p-a-1">
        <h3>How to find time complexity of an algorithm?</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/how-to-solve-any-graph-2d-arrays-maze-interview-questions-in-javascript-dfs-vs-bfs/">
    
      <img src="/images/graph-interview-questions-small.png" width="300" height="250">
      <section class="p-a-1">
        <h3>How to solve any graph/Maze interview questions in JavaScript? DFS vs. BFS</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/priority-queue-data-structure-and-heaps-time-complexity-javascript-implementation/">
    
      <img src="/images/priority-queue-pq-heaps-small.png" width="300" height="250">
      <section class="p-a-1">
        <h3>Priority Queue Data Structure and Heaps Implemented in JavaScript</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial/">
    
      <img src="/images/data-structures-algorithms-time-complexity-big-o-notation-small.jpg" width="300" height="250">
      <section class="p-a-1">
        <h3>How you can change the world by learning Data Structures and Algorithms</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/">
    
      <img src="/images/data-structures-must-know-algorithms-running-time-complexity-small.jpg" width="300" height="250">
      <section class="p-a-1">
        <h3>8 time complexities that every programmer should know</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial/">
    
      <img src="/images/data-structures-time-complexity-lists-arrays-stacks-queues-hash-maps-sets-small.jpg" width="300" height="250">
      <section class="p-a-1">
        <h3>Data Structures in JavaScript: Arrays, HashMaps, and Lists</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/Data-Structures-for-Beginners-Graphs-Time-Complexity-tutorial/">
    
      <img src="/images/graph-data-structures-time-complexity-small.jpg" width="300" height="250">
      <section class="p-a-1">
        <h3>Graph Data Structures in JavaScript for Beginners</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/Data-Structures-for-Beginners-Trees-binary-search-tree-tutorial/">
    
      <img src="/images/data-structures-for-beginners-trees-binary-search-tree-small.jpg" width="300" height="250">
      <section class="p-a-1">
        <h3>Tree Data Structures in JavaScript for Beginners</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/Self-balanced-Binary-Search-Trees-with-AVL-tree-Data-Structure-for-beginners/">
    
      <img src="/images/data-structures-algorithms-avl-binary-search-trees-small.jpg" width="300" height="250">
      <section class="p-a-1">
        <h3>Self-balanced Binary Search Trees with AVL in JavaScript</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
            
              

              <!-- <ol> -->
              <article class="col-md-6 col-sm-6 card">
  <a href="/Analysis-of-Recursive-Algorithms/">
    
      <img src="/images/data-structures-analysis-of-recursive-algorithms-small.jpg" width="300" height="250">
      <section class="p-a-1">
        <h3>Analysis of Recursive Algorithms</h3>
      </section>
    
  </a>
</article>

              <!-- </ol> -->

              
              </div><!-- .row -->
              </div><!-- .container -->
              
            
          </div>

          <!-- 726x88 -->
          <!---->
          <!--<script data-cfasync="false" type="text/javascript" src="(DISABLED)//www.eboundservices.com/ads/728x90_non_responsive.js"></script>-->
<!--           <div class="hidden-mobile-down">
            <script data-cfasync="false" type="text/javascript" src="(DISABLED)//www.eboundservices.com/ads/728x90_responsive.js"></script>
          </div> -->
          <!--<script data-cfasync="false" type="text/javascript" src="//www.eboundservices.com/ads/336x280_responsive.js"></script>-->


          <!-- last working ads -->
          <!-- <script data-cfasync="false" type="text/javascript" src="//www.eboundservices.com/ads/dfp/336x280_responsive.js"></script> -->


        </footer>

      <!-- if(page.layout !== 'snippet') -->
    </section>

    <!-- Asides (Ads, TOC, ...) -->
    <aside class="col-sm-4 p-x-2 col-xs-order-1">
      <section>

        <!-- 300x250 -->
        <!---->
        <!--<script data-cfasync="false" type="text/javascript" src="//www.eboundservices.com/ads/300x250_non_responsive.js"></script>-->
        <!--<div class="hidden-mobile-down">-->
          <!--<script data-cfasync="false" type="text/javascript" src="//www.eboundservices.com/ads/300x250_responsive.js"></script>-->
        <!--</div>-->

        <!--<div class="hidden-mobile-up">-->
        <!--<script data-cfasync="false" type="text/javascript" src="//www.eboundservices.com/ads/336x280_responsive.js"></script>-->
        <!--</div>-->

        <!-- last working ads -->
        <!-- <script data-cfasync="false" type="text/javascript" src="//www.eboundservices.com/ads/dfp/336x280_responsive.js"></script> -->

      </section>

      <section class="sticky-element--start">
        <div class="muted">
          <div class="p-y-1">
            <a href="#" class=""><span id="back-to-top" title="Go back to the top of this page">
              <i class="fa fa-arrow-up"></i> Top
            </span></a>

            <a href="#" class="p-x-3" title="Improve this post" onclick="track('https://github.com/amejiarosario/amejiarosario.github.io/edit/source/source/_posts/2018-05-25-Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial.md')">
              <i class="fa fa-pencil"></i> Edit this post
            </a>
            <!-- <a href="#" title="Share this post"><i class="fa fa-share"></i> Share</a> -->
            <!--<div class="p-y-1">-->
              <!---->
              <!---->
              <!---->
              <!---->
            <!--</div>-->
          </div>

          
            <h3 class="toc-title">Contents</h3>
            <div>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Structures-Big-O-Cheatsheet"><span class="toc-number">1.</span> <span class="toc-text">Data Structures Big-O Cheatsheet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Primitive-Data-Types"><span class="toc-number">2.</span> <span class="toc-text">Primitive Data Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-number">3.</span> <span class="toc-text">Array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays-built-in-operations"><span class="toc-number">3.1.</span> <span class="toc-text">Arrays built-in operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-element-on-an-array"><span class="toc-number">3.2.</span> <span class="toc-text">Insert element on an array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Access-an-element-in-an-array"><span class="toc-number">3.3.</span> <span class="toc-text">Access an element in an array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Search-an-element-in-an-array"><span class="toc-number">3.4.</span> <span class="toc-text">Search an element in an array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deleting-elements-from-an-array"><span class="toc-number">3.5.</span> <span class="toc-text">Deleting elements from an array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-operations-time-complexity"><span class="toc-number">3.6.</span> <span class="toc-text">Array operations time complexity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMaps"><span class="toc-number">4.</span> <span class="toc-text">HashMaps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-vs-Array"><span class="toc-number">4.1.</span> <span class="toc-text">HashMap vs. Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Function"><span class="toc-number">4.2.</span> <span class="toc-text">Hash Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-HashMap-implementation"><span class="toc-number">4.3.</span> <span class="toc-text">Naïve HashMap implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Improving-Hash-Function"><span class="toc-number">4.4.</span> <span class="toc-text">Improving Hash Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Decent-HashMap-Implementation"><span class="toc-number">4.5.</span> <span class="toc-text">Decent HashMap Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optimal-HashMap-Implementation"><span class="toc-number">4.6.</span> <span class="toc-text">Optimal HashMap Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-element-on-a-HashMap-runtime"><span class="toc-number">4.7.</span> <span class="toc-text">Insert element on a HashMap runtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Search-Access-an-element-on-a-HashMap-runtime"><span class="toc-number">4.8.</span> <span class="toc-text">Search&#x2F;Access an element on a HashMap runtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Edit-Delete-element-on-a-HashMap-runtime"><span class="toc-number">4.9.</span> <span class="toc-text">Edit&#x2F;Delete element on a HashMap runtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-operations-time-complexity"><span class="toc-number">4.10.</span> <span class="toc-text">HashMap operations time complexity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sets"><span class="toc-number">5.</span> <span class="toc-text">Sets</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Implementation"><span class="toc-number">5.1.</span> <span class="toc-text">Set Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Operations-runtime"><span class="toc-number">5.2.</span> <span class="toc-text">Set Operations runtime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linked-Lists"><span class="toc-number">6.</span> <span class="toc-text">Linked Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Singly-Linked-Lists"><span class="toc-number">6.1.</span> <span class="toc-text">Singly Linked Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Singly-Linked-Lists-time-complexity"><span class="toc-number">6.2.</span> <span class="toc-text">Singly Linked Lists time complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Doubly-Linked-Lists"><span class="toc-number">6.3.</span> <span class="toc-text">Doubly Linked Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Doubly-Linked-Lists-time-complexity"><span class="toc-number">6.4.</span> <span class="toc-text">Doubly Linked Lists time complexity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stacks"><span class="toc-number">7.</span> <span class="toc-text">Stacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queues"><span class="toc-number">8.</span> <span class="toc-text">Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue-implemented-with-Array-s"><span class="toc-number">8.1.</span> <span class="toc-text">Queue implemented with Array(s)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue-implemented-with-a-Doubly-Linked-List"><span class="toc-number">8.2.</span> <span class="toc-text">Queue implemented with a Doubly Linked List</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">9.</span> <span class="toc-text">Summary</span></a></li></ol>
            </div>

            <!-- 300x600 -->
            <!---->
            <!--<script data-cfasync="false" type="text/javascript" src="(DISABLED)//www.eboundservices.com/ads/300x600_non_responsive.js"></script>-->
            <div class="hidden-mobile-down">
              <!-- last working ads -->
              <!-- <script data-cfasync="false" type="text/javascript" src="//www.eboundservices.com/ads/dfp/160x600_responsive.js"></script> -->

              <a href="https://books.adrianmejia.com" target="_blank">
                <!-- <img src="/images/data-structure-algorithms-javascript-presell.jpg" alt="Data Structure and Algorithms in JavaScript eBook"> -->
                <img src="/images/data-structure-algorithms-banner.jpg" alt="Data Structure and Algorithms in JavaScript eBook">
              </a>
            </div>
          
        </div>
      </section>
    </aside>
  </div>

  <!-- comments -->
  <a id="comments-section"></a>
  <footer class="row sticky-element--end">
    <div class="col-xs-12">
      <section>
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://adrianmejia.com/Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial/';
      this.page.identifier = 'https://adrianmejia.com/Data-Structures-Time-Complexity-for-Beginners-Arrays-HashMaps-Linked-Lists-Stacks-Queues-tutorial/';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = '//adrianmejia.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" href="https://disqus.com/?ref_noscript" rel="nofollow noopener">comments powered by Disqus.</a></noscript>
</section>

    </div>
  </footer>
</article>

    </main>

    <!-- uxa -->
    <!-- <img src="//data.uxeranalytics.com/image1.png?uxa=blog" id="pxl1"> -->
    <!-- <script async defer src="//data.uxeranalytics.com/uxa.js"></script> -->
    <!-- /uxa -->

    <footer class="page-footer">
      <div class="container">
        <div class="p-y-2">
          &copy; 2022 <a href="http://adrianmejia.com">Adrian Mejia</a>
          <span class="muted m-x-4" title="Sat Oct 22 2022 13:43:01 GMT-0400 (Eastern Daylight Time)">
            v.rk617p
          </span>
        </div>
      </div>
    </footer>

    <!-- Scripts -->
    
<script src="/js/main.babel.js"></script>
    <script id="dsq-count-scr" src="//adrianmejia.disqus.com/count.js" async></script>
    <!-- Algolia Search -->
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/instantsearch.js/1/instantsearch.min.css" />
    <script src="//cdn.jsdelivr.net/instantsearch.js/1/instantsearch.min.js"></script>
    
<link rel="stylesheet" href="/stylesheets/55_search.css">



    <!-- social scripts -->
    <script async defer src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
    

    
      <!-- <script src="https://gumroad.com/js/gumroad.js"></script> -->

      <!-- adthis -->
      <script type="text/javascript">
        var addthis_config = {
          data_ga_property: 'UA-24183929-4',
          data_ga_social : true
        };
      </script>
      <script async defer type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-579cb31b46e2f7e6"></script>

      
<script src="/js/posts.babel.js"></script>
      
<script src="/js/posts2.babel.js"></script>
    
  </body>
</html>
